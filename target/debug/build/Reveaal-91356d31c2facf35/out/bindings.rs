/* automatically generated by rust-bindgen 0.54.1 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub type std_string = [u64; 4usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_size_type = u64;
pub type std_allocator_difference_type = u64;
pub type std_allocator_pointer = u8;
pub type std_allocator_const_pointer = u8;
pub type std_allocator_reference = u8;
pub type std_allocator_const_reference = u8;
pub type std_allocator_value_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = u8;
pub type std_ostream = [u64; 34usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector {
    pub _address: u8,
}
pub type std_vector__Base = u8;
pub type std_vector__Tp_alloc_type = u8;
pub type std_vector__Alloc_traits = u8;
pub type std_vector_value_type = u8;
pub type std_vector_pointer = u8;
pub type std_vector_const_pointer = u8;
pub type std_vector_reference = u8;
pub type std_vector_const_reference = u8;
pub type std_vector_iterator = u8;
pub type std_vector_const_iterator = u8;
pub type std_vector_const_reverse_iterator = u8;
pub type std_vector_reverse_iterator = u8;
pub type std_vector_size_type = u64;
pub type std_vector_difference_type = u64;
pub type std_vector_allocator_type = u8;
pub type size_t = ::std::os::raw::c_ulong;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub const BOOL_FALSE: BOOL = 0;
pub const BOOL_TRUE: BOOL = 1;
pub type BOOL = u32;
#[doc = " Type for indices (variables and clocks)."]
pub type cindex_t = u32;
#[doc = " A simple reference with maximal capacity for access checks."]
#[doc = " This is a pointer to some bounded memory. array_t is defined"]
#[doc = " too, but pointer_t has no memory management, it is only a reference."]
#[doc = " Accesses ptr[i] are checked. Main purpose is debugging + simple"]
#[doc = " iteration. std::vector does not provide these debugging capabilities."]
#[doc = " Everything is assumed to be 32 bits aligned"]
#[doc = " so this wrapper is obviously not designed"]
#[doc = " for int8 or int16 types."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct base_pointer_t<T> {
    #[doc = "< data pointed"]
    pub data: *mut T,
    #[doc = "< size of data, important for checks"]
    pub capa: size_t,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
pub struct base_Object__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Base class to derive from if you want"]
#[doc = " to use Pointer<of something>. The reference"]
#[doc = " counting is done by Object."]
#[repr(C)]
#[derive(Debug)]
pub struct base_Object {
    pub vtable_: *const base_Object__bindgen_vtable,
    #[doc = "< reference counter"]
    pub refCounter: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_base_Object() {
    assert_eq!(
        ::std::mem::size_of::<base_Object>(),
        16usize,
        concat!("Size of: ", stringify!(base_Object))
    );
    assert_eq!(
        ::std::mem::align_of::<base_Object>(),
        8usize,
        concat!("Alignment of ", stringify!(base_Object))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<base_Object>())).refCounter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(base_Object),
            "::",
            stringify!(refCounter)
        )
    );
}
extern "C" {
    #[doc = " Add a reference to this object."]
    #[doc = " Use carefully because this will"]
    #[doc = " affect deallocation."]
    #[link_name = "\u{1}addReference"]
    pub fn base_Object_addReference(this: *mut base_Object);
}
extern "C" {
    #[doc = " Remove a reference to this object."]
    #[doc = " Use carefully because this will"]
    #[doc = " affect deallocation."]
    #[link_name = "\u{1}dropReference"]
    pub fn base_Object_dropReference(this: *mut base_Object);
}
extern "C" {
    #[doc = " This is useful to know if this object"]
    #[doc = " may be modified safely."]
    #[doc = " @return true if there is only one reference"]
    #[doc = " to this object."]
    #[link_name = "\u{1}isMutable"]
    pub fn base_Object_isMutable(this: *const base_Object) -> bool;
}
extern "C" {
    #[doc = " Constructor: initialize the reference counter."]
    #[link_name = "\u{1}Object"]
    pub fn base_Object_Object(this: *mut base_Object);
}
impl base_Object {
    #[inline]
    pub unsafe fn addReference(&mut self) {
        base_Object_addReference(self)
    }
    #[inline]
    pub unsafe fn dropReference(&mut self) {
        base_Object_dropReference(self)
    }
    #[inline]
    pub unsafe fn isMutable(&self) -> bool {
        base_Object_isMutable(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        base_Object_Object(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " Destructor."]
    #[link_name = "\u{1}Object_destructor"]
    pub fn base_Object_Object_destructor(this: *mut base_Object);
}
extern "C" {
    #[doc = " Wrapper to delete. It is virtual in"]
    #[doc = " case we have objects that are not deallocated"]
    #[doc = " by delete, in which case, the method is"]
    #[doc = " overriden."]
    #[link_name = "\u{1}destroy"]
    pub fn base_Object_destroy(this: *mut ::std::os::raw::c_void);
}
#[doc = "< incomparable     | not (set1 <= set2)"]
pub const relation_t_base_DIFFERENT: relation_t = 0;
#[doc = "< set1 > set2      | not used"]
pub const relation_t_base_SUPERSET: relation_t = 1;
#[doc = "< same as superset |"]
pub const relation_t_base_GREATER: relation_t = 1;
#[doc = "< set1 < set2      | set1 <= set2"]
pub const relation_t_base_SUBSET: relation_t = 2;
#[doc = "< same as subset   |"]
pub const relation_t_base_LESS: relation_t = 2;
#[doc = "< set1 == set2     | not used"]
pub const relation_t_base_EQUAL: relation_t = 3;
#[doc = " Partial order relations between two sets:"]
#[doc = " the values depend on \"exactness\" of relations."]
pub type relation_t = u32;
#[doc = " To distinguish normal integers and those"]
#[doc = " representing constraints. \"raw\" is used"]
#[doc = " because it represents an encoding and this"]
#[doc = " is the raw representation of it."]
pub type raw_t = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct constraint_t {
    pub i: cindex_t,
    pub j: cindex_t,
    pub value: raw_t,
}
#[test]
fn bindgen_test_layout_constraint_t() {
    assert_eq!(
        ::std::mem::size_of::<constraint_t>(),
        12usize,
        concat!("Size of: ", stringify!(constraint_t))
    );
    assert_eq!(
        ::std::mem::align_of::<constraint_t>(),
        4usize,
        concat!("Alignment of ", stringify!(constraint_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<constraint_t>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(constraint_t),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<constraint_t>())).j as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(constraint_t),
            "::",
            stringify!(j)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<constraint_t>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(constraint_t),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}constraint_t"]
    pub fn constraint_t_constraint_t(this: *mut constraint_t);
}
extern "C" {
    #[link_name = "\u{1}constraint_t"]
    pub fn constraint_t_constraint_t1(this: *mut constraint_t, c: *const constraint_t);
}
extern "C" {
    #[link_name = "\u{1}constraint_t"]
    pub fn constraint_t_constraint_t2(
        this: *mut constraint_t,
        ci: cindex_t,
        cj: cindex_t,
        vij: raw_t,
    );
}
extern "C" {
    #[link_name = "\u{1}constraint_t"]
    pub fn constraint_t_constraint_t3(
        this: *mut constraint_t,
        ci: cindex_t,
        cj: cindex_t,
        bound: i32,
        isStrict: bool,
    );
}
impl constraint_t {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        constraint_t_constraint_t(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(c: *const constraint_t) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        constraint_t_constraint_t1(__bindgen_tmp.as_mut_ptr(), c);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(ci: cindex_t, cj: cindex_t, vij: raw_t) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        constraint_t_constraint_t2(__bindgen_tmp.as_mut_ptr(), ci, cj, vij);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(ci: cindex_t, cj: cindex_t, bound: i32, isStrict: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        constraint_t_constraint_t3(__bindgen_tmp.as_mut_ptr(), ci, cj, bound, isStrict);
        __bindgen_tmp.assume_init()
    }
}
#[doc = "< strict less than constraints:  < x"]
pub const strictness_t_dbm_STRICT: strictness_t = 0;
#[doc = "< less or equal constraints   : <= x"]
pub const strictness_t_dbm_WEAK: strictness_t = 1;
#[doc = " Bound *strictness*. Vital constant values *DO NOT CHANGE*."]
pub type strictness_t = u32;
extern "C" {
    #[doc = " Initialize a DBM with:"]
    #[doc = " - <= 0 on the diagonal and the 1st row"]
    #[doc = " - <= infinity elsewhere"]
    #[doc = " @param dbm: DBM to initialize."]
    #[doc = " @param dim: dimension."]
    #[doc = " @return initialized DBM."]
    #[doc = " @post DBM is closed."]
    pub fn dbm_init(dbm: *mut raw_t, dim: cindex_t);
}
extern "C" {
    #[doc = " Equality test with trivial dbm as obtained from"]
    #[doc = " dbm_init(dbm, dim)."]
    #[doc = " @param dbm: DBM to test"]
    #[doc = " @param dim: dimension."]
    pub fn dbm_isEqualToInit(dbm: *const raw_t, dim: cindex_t) -> BOOL;
}
extern "C" {
    #[doc = " Test if a DBM contains the zero point of not."]
    #[doc = " @param dbm: DBM to test."]
    #[doc = " @param dim: dimension."]
    #[doc = " @return TRUE if the DBM contains the origin 0, FALSE otherwise."]
    pub fn dbm_hasZero(dbm: *const raw_t, dim: cindex_t) -> BOOL;
}
extern "C" {
    #[doc = " Convex hull union between 2 DBMs."]
    #[doc = " @param dbm1,dbm2: DBMs."]
    #[doc = " @param dim: dimension"]
    #[doc = " @pre"]
    #[doc = " - both DBMs have the same dimension"]
    #[doc = " - both DBMs are closed and non empty"]
    #[doc = " @return dbm1 = dbm1 U dbm2"]
    #[doc = " @post dbm1 is closed."]
    pub fn dbm_convexUnion(dbm1: *mut raw_t, dbm2: *const raw_t, dim: cindex_t);
}
extern "C" {
    #[doc = " Intersection of 2 DBMs."]
    #[doc = " @param dbm1,dbm2: DBMs."]
    #[doc = " @param dim: dimension."]
    #[doc = " @pre"]
    #[doc = " - both DBMs have the same dimension"]
    #[doc = " - both DBMs are closed and non empty"]
    #[doc = " @return dbm1 = dbm1 intersected with dbm2 and"]
    #[doc = " TRUE if dbm1 is non empty."]
    #[doc = " @post dbm1 is closed and non empty OR dbm1 is empty."]
    pub fn dbm_intersection(dbm1: *mut raw_t, dbm2: *const raw_t, dim: cindex_t) -> BOOL;
}
extern "C" {
    #[doc = " Relaxed intersection of 2 DBMs."]
    #[doc = " @param dbm1,dbm2: DBMs."]
    #[doc = " @param dim: dimension."]
    #[doc = " @pre"]
    #[doc = " - both DBMs have the same dimension"]
    #[doc = " - both DBMs are closed and non empty"]
    #[doc = " - dim > 0"]
    #[doc = " @return dst = relaxed(dbm1) intersected with relaxed(dbm2) and"]
    #[doc = " TRUE if dst is non empty."]
    #[doc = " @post dst is closed and non empty OR dst is empty."]
    pub fn dbm_relaxedIntersection(
        dst: *mut raw_t,
        dbm1: *const raw_t,
        dbm2: *const raw_t,
        dim: cindex_t,
    ) -> BOOL;
}
extern "C" {
    #[doc = " Test if 2 DBMs have an intersection."]
    #[doc = " @param dbm1,dbm2: DBMs to test."]
    #[doc = " @param dim: dimension of both DBMs."]
    #[doc = " @return FALSE if dbm1 intersection dbm2 is empty"]
    #[doc = " and TRUE if it *may* be non empty (not guaranteed)."]
    pub fn dbm_haveIntersection(dbm1: *const raw_t, dbm2: *const raw_t, dim: cindex_t) -> BOOL;
}
extern "C" {
    #[doc = " Constrain a DBM with a constraint."]
    #[doc = " USAGE:"]
    #[doc = " -# dbm must be closed."]
    #[doc = " -# reset touched: base_resetBits(touched, size)"]
    #[doc = " -# apply constraints: dbm_constrain(...)"]
    #[doc = " -# if not empty dbm_close(dbm, dim, touched)"]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @param i,j,constraint: the clock constraint xi-xj <= constraint"]
    #[doc = " (or < constraint) according to the clock constraint encoding."]
    #[doc = " @param touched: bit table to keep track of modified clocks."]
    #[doc = " @return: FALSE if the DBM is empty, TRUE otherwise, the constrained"]
    #[doc = " DBM, and which clocks were modified (touched)."]
    #[doc = " It is not guaranteed that the DBM is non empty, but"]
    #[doc = " if FALSE is returned then the DBM is guaranteed to be empty."]
    #[doc = " @pre"]
    #[doc = " - touched is at least a uint32_t[bits2intsize(dim)]"]
    #[doc = " - constraint is finite"]
    #[doc = " - dim > 1 induced by i < dim & j < dim & i != j"]
    #[doc = " - i < dim, j < dim, i != j"]
    #[doc = " @post THE RESULTING DBM MAY NOT BE CLOSED, calls to isEmpty"]
    #[doc = " can return erroneous results."]
    pub fn dbm_constrain(
        dbm: *mut raw_t,
        dim: cindex_t,
        i: cindex_t,
        j: cindex_t,
        constraint: raw_t,
        touched: *mut u32,
    ) -> BOOL;
}
extern "C" {
    #[doc = " Constrain a DBM with several constraints."]
    #[doc = " USAGE:"]
    #[doc = " @param dbm: DBM"]
    #[doc = " @param dim: dimension."]
    #[doc = " @param constraints, n: the n constraints to use."]
    #[doc = " @pre"]
    #[doc = " - DBM closed and non empty."]
    #[doc = " - valid constraint: not of the form xi-xi <= something"]
    #[doc = " - dim > 1 induced by i < dim & j < dim & i != j"]
    #[doc = " - constraints[*].{i,j} < dim"]
    #[doc = " @return TRUE if the DBM is non empty, the constrained"]
    #[doc = " DBM"]
    #[doc = " @post the resulting DBM is closed if it is non empty."]
    pub fn dbm_constrainN(
        dbm: *mut raw_t,
        dim: cindex_t,
        constraints: *const constraint_t,
        n: size_t,
    ) -> BOOL;
}
extern "C" {
    #[doc = " Constrain a DBM with several constraints using a table for"]
    #[doc = " index translation (translates absolute clock indices to"]
    #[doc = " local clock indices for this DBM)."]
    #[doc = " USAGE:"]
    #[doc = " @param dbm: DBM"]
    #[doc = " @param dim: dimension."]
    #[doc = " @param indexTable: table for index translation"]
    #[doc = " @param constraints, n: the n constraints to use."]
    #[doc = " @pre"]
    #[doc = " - DBM closed and non empty."]
    #[doc = " - valid constraint: not of the form xi-xi <= something"]
    #[doc = " - dim > 1 induced by i < dim & j < dim & i != j"]
    #[doc = " - constraints[*].{i,j} < dim"]
    #[doc = " @return TRUE if the DBM is non empty, the constrained"]
    #[doc = " DBM"]
    #[doc = " @post the resulting DBM is closed if it is non empty."]
    pub fn dbm_constrainIndexedN(
        dbm: *mut raw_t,
        dim: cindex_t,
        indexTable: *const cindex_t,
        constraints: *const constraint_t,
        n: size_t,
    ) -> BOOL;
}
extern "C" {
    #[doc = " Constrain a DBM with one constraint."]
    #[doc = " If you have several constraints, it may be better to"]
    #[doc = " use the previous functions."]
    #[doc = " @param dbm: DBM, ASSUME: closed."]
    #[doc = " @param dim: dimension."]
    #[doc = " @param i,j,constraint: constraint for xi-xj to use"]
    #[doc = " @pre"]
    #[doc = " - DBM is closed and non empty"]
    #[doc = " - dim > 1 induced by i < dim & j < dim & i != j"]
    #[doc = " - as a consequence: i>=0 & j>=0 & i!=j => (i or j) > 0"]
    #[doc = "   and dim > (i or j) > 0 => dim > 1"]
    #[doc = " - i < dim, j < dim, i != j"]
    #[doc = " @return TRUE if the DBM is non empty and the constrained"]
    #[doc = " DBM."]
    #[doc = " @post the resulting DBM is closed if it is non empty."]
    pub fn dbm_constrain1(
        dbm: *mut raw_t,
        dim: cindex_t,
        i: cindex_t,
        j: cindex_t,
        constraint: raw_t,
    ) -> BOOL;
}
extern "C" {
    #[doc = " Delay operation."]
    #[doc = " Remove constraints of the form xi-x0 <= ci"]
    #[doc = " and replace them by xi-x0 < infinity."]
    #[doc = " It is also called strongest post-condition."]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @pre"]
    #[doc = " - DBM closed and non empty"]
    #[doc = " @post DBM is closed."]
    pub fn dbm_up(dbm: *mut raw_t, dim: cindex_t);
}
extern "C" {
    #[doc = " Delay operation with stopped clocks."]
    #[doc = " Apply delay except for a number of stopped clocks. The"]
    #[doc = " constraints of the form xi-x0 <= ci are replaced by"]
    #[doc = " xi-x0 <= infinity for the \"running\" clocks xi and the"]
    #[doc = " constraints xj-xi <= cji are replaced by xj-xi <= infinity"]
    #[doc = " for xj \"running\" and xi stopped (j > 0)."]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @pre"]
    #[doc = " - DBM closed and non empty"]
    #[doc = " - stopped != NULL and stopped is a uint32_t[bits2intsize(dim)]"]
    #[doc = " @post DBM is closed"]
    pub fn dbm_up_stop(dbm: *mut raw_t, dim: cindex_t, stopped: *const u32);
}
extern "C" {
    #[doc = " Internal dbm_down, don't use directly"]
    pub fn dbm_downFrom(dbm: *mut raw_t, dim: cindex_t, j0: cindex_t);
}
extern "C" {
    #[doc = " Inverse delay operation with stopped clocks."]
    #[doc = " This one is more tricky: 1) It lowers the lower"]
    #[doc = " bounds of the clocks to 0 or the minimum it can"]
    #[doc = " be (due to other constraints) *for the clocks"]
    #[doc = " that are running*. 2) It recomputes the lower"]
    #[doc = " diagonal constraints between running and stopped"]
    #[doc = " clocks."]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @pre"]
    #[doc = " - DBM clocsed and non empty."]
    #[doc = " - stopped != NULL and stopped is a uint32_t[bits2intsize(dim)]"]
    #[doc = " @post DBM is closed."]
    pub fn dbm_down_stop(dbm: *mut raw_t, dim: cindex_t, stopped: *const u32);
}
extern "C" {
    #[doc = " Former \"reset\" operation, properly called update."]
    #[doc = " Implement the operation x := v, where x is a clock and v"]
    #[doc = " a positive integer."]
    #[doc = " @param dbm: DBM"]
    #[doc = " @param dim: dimension."]
    #[doc = " @param index: clock index."]
    #[doc = " @param value: value to reset to (may be non null), must be >=0.."]
    #[doc = " @pre"]
    #[doc = " - DBM closed and non empty"]
    #[doc = " - dim > 1 induced by index > 0 and index < dim"]
    #[doc = " - index > 0: never reset reference clock, index < dim"]
    #[doc = " - value is finite and not an encoded clock constraint"]
    #[doc = " - value >= 0 (int used for type convenience and compatibility)."]
    #[doc = " @post DBM is closed."]
    pub fn dbm_updateValue(dbm: *mut raw_t, dim: cindex_t, index: cindex_t, value: i32);
}
extern "C" {
    #[doc = " Free operation. Remove all constraints (lower and upper"]
    #[doc = " bounds) for a given clock, i.e., set them to infinity,"]
    #[doc = " except for x0-xk <= 0."]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @param index: the clock to free."]
    #[doc = " @pre"]
    #[doc = " - DBM is closed and non empty"]
    #[doc = " - dim > 1 induced by index > 0 && index < dim"]
    #[doc = " - index > 0, index < dim"]
    #[doc = " @post DBM is closed."]
    pub fn dbm_freeClock(dbm: *mut raw_t, dim: cindex_t, index: cindex_t);
}
extern "C" {
    #[doc = " Free all upper bounds for a given clock."]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @param index: the concerned clock."]
    #[doc = " @pre DBM closed and non empty and 0 < index < dim"]
    #[doc = " @post DBM is closed and non empty."]
    pub fn dbm_freeUp(dbm: *mut raw_t, dim: cindex_t, index: cindex_t);
}
extern "C" {
    #[doc = " Free all upper bounds for all clocks."]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @pre DBM closed and non empty."]
    #[doc = " @post DBM closed and non empty."]
    pub fn dbm_freeAllUp(dbm: *mut raw_t, dim: cindex_t);
}
extern "C" {
    #[doc = " @return true if dbm_freeAllUp(dbm,dim) has"]
    #[doc = " no effect on dbm."]
    #[doc = " @param dbm,dim: DBM of dimension dim to test."]
    pub fn dbm_isFreedAllUp(dbm: *const raw_t, dim: cindex_t) -> BOOL;
}
extern "C" {
    #[doc = " @return 0 if dbm_freeAllDown(dbm,dim) has"]
    #[doc = " no effect on dbm, or (j << 16)|i otherwise"]
    #[doc = " where i and j are the indices from where dbm"]
    #[doc = " differs from its expected result."]
    #[doc = " @param dbm,dim: DBM of dimension dim to test."]
    pub fn dbm_testFreeAllDown(dbm: *const raw_t, dim: cindex_t) -> u32;
}
extern "C" {
    #[doc = " Free all lower bounds for a given clock."]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @param index: index of the clock to \"down-free\""]
    #[doc = " @pre"]
    #[doc = " - dim > 1 induced by index > 0 && index < dim"]
    #[doc = " - index > 0, index < dim"]
    #[doc = " - DBM closed and non empty"]
    #[doc = " @post DBM is closed and non empty."]
    pub fn dbm_freeDown(dbm: *mut raw_t, dim: cindex_t, index: cindex_t);
}
extern "C" {
    #[doc = " Free all lower bounds for all clocks."]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @pre DBM closed and non empty."]
    #[doc = " @post DBM closed and non empty."]
    pub fn dbm_freeAllDown(dbm: *mut raw_t, dim: cindex_t);
}
extern "C" {
    #[doc = " Clock copy operation = update clock:"]
    #[doc = " xi := xj, where xi and xj are clocks."]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @param i,j: indices of the clocks."]
    #[doc = " @pre"]
    #[doc = " - DBM closed and non empty."]
    #[doc = " - dim > 1 induced by i > 0 & i < dim"]
    #[doc = " - i > 0, j > 0, i < dim, j < dim"]
    #[doc = " @post DBM is closed."]
    pub fn dbm_updateClock(dbm: *mut raw_t, dim: cindex_t, i: cindex_t, j: cindex_t);
}
extern "C" {
    #[doc = " Increment operation: xi := xi + value, where xi is a clock."]
    #[doc = " WARNING: if offset is negative it may be incorrect to use this."]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @param i: index of the clock."]
    #[doc = " @param value: the increment."]
    #[doc = " @pre"]
    #[doc = " - DBM closed and non empty."]
    #[doc = " - dim > 1 induced by i > 0 && i < dim"]
    #[doc = " - i > 0, i < dim"]
    #[doc = " - if value < 0, then |value| <= min bound of clock i"]
    #[doc = " @post DBM is closed."]
    pub fn dbm_updateIncrement(dbm: *mut raw_t, dim: cindex_t, i: cindex_t, value: i32);
}
extern "C" {
    #[doc = " More general update operation: xi := xj + value,"]
    #[doc = " where xi and yi are clocks."]
    #[doc = " WARNING: if offset is negative it may be incorrect to use this."]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @param i,j: indices of the clocks."]
    #[doc = " @param value: the increment."]
    #[doc = " @pre"]
    #[doc = " - DBM is closed and non empty."]
    #[doc = " - dim > 1 induced by i > 0 && i < dim"]
    #[doc = " - i > 0, j > 0, j < dim, i < dim"]
    #[doc = " - if value < 0 then |value| <= min bound of clock j"]
    #[doc = " @post DBM is closed."]
    pub fn dbm_update(dbm: *mut raw_t, dim: cindex_t, i: cindex_t, j: cindex_t, value: i32);
}
extern "C" {
    #[doc = " @return constraint clock to == value, and return"]
    #[doc = " if the result is non empty."]
    #[doc = " @param dbm,dim: DBM of dimension dim"]
    #[doc = " @param clock: clock index for the reset"]
    #[doc = " @param value: reset value to apply"]
    #[doc = " @pre clock != 0 (not ref clock) && clock < dim"]
    pub fn dbm_constrainClock(dbm: *mut raw_t, dim: cindex_t, clock: cindex_t, value: i32) -> BOOL;
}
extern "C" {
    #[doc = " Check if a DBM is empty by looking"]
    #[doc = " at its diagonal. There should be only == 0"]
    #[doc = " constraints."]
    #[doc = " NOTE: one should never need to call this function"]
    #[doc = " manually, unless for debugging."]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @pre"]
    #[doc = " - the close function was run before on the dbm"]
    #[doc = " @return: TRUE if empty, FALSE otherwise."]
    pub fn dbm_isEmpty(dbm: *const raw_t, dim: cindex_t) -> BOOL;
}
extern "C" {
    #[doc = " Close operation. Complexity: cubic in dim."]
    #[doc = " Apply Floyd's shortest path algorithm."]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @return TRUE if the DBM is non empty."]
    #[doc = " @post DBM is closed *if* non empty."]
    #[doc = " @pre if dim == 1 then *dbm==dbm_LE_ZERO: close has"]
    #[doc = " not sense and will not work for dim == 1."]
    pub fn dbm_close(dbm: *mut raw_t, dim: cindex_t) -> BOOL;
}
extern "C" {
    #[doc = " Check that a DBM is closed. This test is as"]
    #[doc = " expensive as dbm_close! It is there mainly for"]
    #[doc = " testing/debugging purposes."]
    #[doc = " @param dbm: DBM to check."]
    #[doc = " @param dim: dimension."]
    #[doc = " @return TRUE if DBM is closed and non empty,"]
    #[doc = " FALSE otherwise."]
    pub fn dbm_isClosed(dbm: *const raw_t, dim: cindex_t) -> BOOL;
}
extern "C" {
    #[doc = " Close operation. Complexity: custom*dim*dim,"]
    #[doc = " where custom is the number of clocks to look at."]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @param touched: bit table that tells which clocks"]
    #[doc = " to look at."]
    #[doc = " @pre"]
    #[doc = " - touched is at least a uint32_t[bit2intsize(dim)]"]
    #[doc = " - if there is no bit set (nothing to do) then"]
    #[doc = "   the input DBM is non empty."]
    #[doc = " @return TRUE if the dbm is non empty."]
    pub fn dbm_closex(dbm: *mut raw_t, dim: cindex_t, touched: *const u32) -> BOOL;
}
extern "C" {
    #[doc = " Close operation for 1 clock. Complexity: dim*dim."]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @param k: the clock for which the closure applies."]
    #[doc = " @pre"]
    #[doc = " - k < dim"]
    #[doc = " @return TRUE if the DBM is non empty."]
    pub fn dbm_close1(dbm: *mut raw_t, dim: cindex_t, k: cindex_t) -> BOOL;
}
extern "C" {
    #[doc = " Specialization of close valid if only one"]
    #[doc = " constraint cij is tightened, ie, DBM is closed,"]
    #[doc = " you tighten DBM[i,j] only, then this function"]
    #[doc = " recomputes the closure more efficiently than"]
    #[doc = " calling close1(i) and close1(j)."]
    #[doc = " @param dbm: DBM"]
    #[doc = " @param dim: dimension"]
    #[doc = " @param i,j: the constraint that was tightened"]
    #[doc = " @see Rokicki's thesis page 171."]
    #[doc = " @pre"]
    #[doc = " - dim > 1 induced by i!=j & i < dim & j < dim"]
    #[doc = " - i != j, i < dim, j < dim"]
    #[doc = " - DBM non empty:"]
    #[doc = "   DBM[i,j] + DBM[j,i] >= 0, ie, the tightening"]
    #[doc = "   still results in a non empty DBM. If we have"]
    #[doc = "   < 0 then this close should not be called"]
    #[doc = "   at all because we know the DBM is empty."]
    #[doc = " @post DBM is not empty"]
    pub fn dbm_closeij(dbm: *mut raw_t, dim: cindex_t, i: cindex_t, j: cindex_t);
}
extern "C" {
    #[doc = " Check if a DBM is unbounded, i.e., if one point"]
    #[doc = " can delay infinitely."]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @return TRUE if unbounded, FALSE otherwise."]
    #[doc = " @pre"]
    #[doc = " - dbm_isValid(dbm, dim)"]
    pub fn dbm_isUnbounded(dbm: *const raw_t, dim: cindex_t) -> BOOL;
}
extern "C" {
    #[doc = " Relation between 2 dbms."]
    #[doc = " See relation_t."]
    #[doc = " @param dbm1,dbm2: DBMs to be tested."]
    #[doc = " @param dim: dimension of the DBMS."]
    #[doc = " @pre"]
    #[doc = " - dbm1 and dbm2 have the same dimension"]
    #[doc = " - dbm_isValid for both DBMs"]
    #[doc = " @return: exact relation result, @see relation_t."]
    pub fn dbm_relation(dbm1: *const raw_t, dbm2: *const raw_t, dim: cindex_t) -> relation_t;
}
extern "C" {
    #[doc = " Test only if dbm1 <= dbm2."]
    #[doc = " @param dbm1,dbm2: DBMs to be tested."]
    #[doc = " @param dim: dimension of the DBMs."]
    #[doc = " @pre"]
    #[doc = " - dbm1 and dbm2 have the same dimension"]
    #[doc = " - dbm_isValid for both DBMs"]
    #[doc = " @return TRUE if dbm1 <= dbm2, FALSE otherwise."]
    pub fn dbm_isSubsetEq(dbm1: *const raw_t, dbm2: *const raw_t, dim: cindex_t) -> BOOL;
}
extern "C" {
    #[doc = " Relax upper bounds of a given clocks, ie, make them weak."]
    #[doc = " @param dbm, dim: DBM of dimension dim"]
    #[doc = " @param clock: clock to relax."]
    #[doc = " @pre (dim > 0 induced by) clock >= 0 && clock < dim"]
    #[doc = " && dbm_isValid(dbm,dim)"]
    #[doc = " @post DBM is closed and non empty"]
    pub fn dbm_relaxUpClock(dbm: *mut raw_t, dim: cindex_t, clock: cindex_t);
}
extern "C" {
    #[doc = " Relax lower bounds of a given clocks, ie, make them weak."]
    #[doc = " @param dbm, dim: DBM of dimension dim"]
    #[doc = " @param clock: clock to relax."]
    #[doc = " @pre (dim > 0 induced by) clock >= 0 && clock < dim"]
    #[doc = " && dbm_isValid(dbm,dim)"]
    #[doc = " @post DBM is closed and non empty"]
    pub fn dbm_relaxDownClock(dbm: *mut raw_t, dim: cindex_t, clock: cindex_t);
}
extern "C" {
    #[doc = " Relax all bounds so that they are non strict (except"]
    #[doc = " for infinity)."]
    #[doc = " @param dbm,dim: DBM of dimension dim."]
    #[doc = " @pre dbm_isValid(dbm, dim)"]
    #[doc = " @post dbm_isValid(dbm, dim)"]
    pub fn dbm_relaxAll(dbm: *mut raw_t, dim: cindex_t);
}
extern "C" {
    #[doc = " Constrain all lower bounds to be strict."]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @pre dbm_isValid(dbm,dim)"]
    #[doc = " @return TRUE if the DBM is non empty and closed, 0 otherwise."]
    pub fn dbm_tightenDown(dbm: *mut raw_t, dim: cindex_t) -> BOOL;
}
extern "C" {
    #[doc = " Constrain all upper bounds to be strict."]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @pre dbm_isValid(dbm,dim)"]
    #[doc = " @return TRUE if the DBM is non empty and closed, 0 otherwise."]
    pub fn dbm_tightenUp(dbm: *mut raw_t, dim: cindex_t) -> BOOL;
}
extern "C" {
    #[doc = " Test if a (discrete) point is included in the"]
    #[doc = " zone represented by the DBM."]
    #[doc = " @param pt: the point"]
    #[doc = " @param dbm: DBM"]
    #[doc = " @param dim: dimension"]
    #[doc = " @pre"]
    #[doc = " - pt is a int32_t[dim]"]
    #[doc = " - dbm is a raw_t[dim*dim]"]
    #[doc = " - dbm is closed"]
    #[doc = " @return TRUE if the pt satisfies the constraints of dbm"]
    pub fn dbm_isPointIncluded(pt: *const i32, dbm: *const raw_t, dim: cindex_t) -> BOOL;
}
extern "C" {
    #[doc = " Test if a (real) point is included in the"]
    #[doc = " zone represented by the DBM."]
    #[doc = " @param pt: the point"]
    #[doc = " @param dbm: DBM"]
    #[doc = " @param dim: dimension"]
    #[doc = " @pre"]
    #[doc = " - pt is a int32_t[dim]"]
    #[doc = " - dbm is a raw_t[dim*dim]"]
    #[doc = " - dbm is closed"]
    #[doc = " @return TRUE if the pt satisfies the constraints of dbm"]
    pub fn dbm_isRealPointIncluded(pt: *const f64, dbm: *const raw_t, dim: cindex_t) -> BOOL;
}
extern "C" {
    #[doc = " Classical extrapolation based on maximal bounds,"]
    #[doc = " formerly called k-normalization."]
    #[doc = ""]
    #[doc = " Extrapolate the zone using maximal constants:"]
    #[doc = " - if dbm[i,j] >  max_xi then set it to infinity"]
    #[doc = " - if dbm[i,j] < -max_xj then set it to < -max_xj"]
    #[doc = " - otherwise don't touch dbm[i,j]"]
    #[doc = ""]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @param max: table of maximal constants to use for the clocks."]
    #[doc = " @pre"]
    #[doc = " - DBM is closed and non empty"]
    #[doc = " - max is a int32_t[dim]"]
    #[doc = " - max[0] = 0 (reference clock)"]
    #[doc = " @post DBM is closed"]
    pub fn dbm_extrapolateMaxBounds(dbm: *mut raw_t, dim: cindex_t, max: *const i32);
}
extern "C" {
    #[doc = " Diagonal extrapolation based on maximal bounds."]
    #[doc = ""]
    #[doc = " Update dbm[i,j] with"]
    #[doc = " - infinity if dbm[i,j] > max_xi"]
    #[doc = " - infinity if dbm[0,i] < -max_xi"]
    #[doc = " - infinity if dbm[0,j] < -max_xj, i != 0"]
    #[doc = " - <-max_xj if dbm[i,j] < -max_xj, i == 0"]
    #[doc = " - dbm[i,j] otherwise"]
    #[doc = ""]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @param max: table of maximal constants."]
    #[doc = " @pre"]
    #[doc = " - DBM is closed and non empty"]
    #[doc = " - max is a int32_t[dim]"]
    #[doc = " - max[0] = 0 (reference clock)"]
    #[doc = " @post DBM is closed."]
    pub fn dbm_diagonalExtrapolateMaxBounds(dbm: *mut raw_t, dim: cindex_t, max: *const i32);
}
extern "C" {
    #[doc = " Extrapolation based on lower-upper bounds."]
    #[doc = ""]
    #[doc = " - if dbm[i,j] > lower_xi then dbm[i,j] = infinity"]
    #[doc = " - if dbm[i,j] < -upper_xj then dbm[i,j] = < -upper_xj"]
    #[doc = ""]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @param lower: lower bounds."]
    #[doc = " @param upper: upper bounds."]
    #[doc = " @pre"]
    #[doc = " - DBM is closed"]
    #[doc = " - lower and upper are int32_t[dim]"]
    #[doc = " - lower[0] = upper[0] = 0 (reference clock)"]
    #[doc = " @post DBM is closed."]
    pub fn dbm_extrapolateLUBounds(
        dbm: *mut raw_t,
        dim: cindex_t,
        lower: *const i32,
        upper: *const i32,
    );
}
extern "C" {
    #[doc = " Diagonal extrapolation based on lower-upper bounds."]
    #[doc = " Most general approximation."]
    #[doc = ""]
    #[doc = " Update dbm[i,j] with"]
    #[doc = " - infinity if dbm[i,j] > lower_xi"]
    #[doc = " - infinity if dbm[0,i] < -lower_xi"]
    #[doc = " - infinity if dbm[0,j] < -upper_xj for i != 0"]
    #[doc = " - <-upper_xj if dbm[0,j] < -upper_xj for i = 0"]
    #[doc = " - dbm[i,j] otherwise"]
    #[doc = ""]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @param lower: lower bounds."]
    #[doc = " @param upper: upper bounds."]
    #[doc = " @pre"]
    #[doc = " - DBM is closed and non empty"]
    #[doc = " - lower and upper are int32_t[dim]"]
    #[doc = " - lower[0] = upper[0] = 0 (reference clock)"]
    #[doc = " @post DBM is closed."]
    pub fn dbm_diagonalExtrapolateLUBounds(
        dbm: *mut raw_t,
        dim: cindex_t,
        lower: *const i32,
        upper: *const i32,
    );
}
extern "C" {
    #[doc = " Shrink and expand a DBM:"]
    #[doc = " - takes 2 bit arrays: the source array marks which"]
    #[doc = " clocks are used in the source DBM, and the"]
    #[doc = " destination array marks the clocks in the destination"]
    #[doc = " DBM"]
    #[doc = " - removes clock constraints in source and not"]
    #[doc = "   in destination"]
    #[doc = " - adds clock constraints not in source and in"]
    #[doc = "   destination"]
    #[doc = " - leaves clock constraints that are in source"]
    #[doc = "   and in destination"]
    #[doc = ""]
    #[doc = " @param dbmSrc: source DBM"]
    #[doc = " @param dimSrc: dimension of dbmSrc"]
    #[doc = " @param dbmDst: destination DBM"]
    #[doc = " @param bitSrc: source bit array"]
    #[doc = " @param bitDst: destination bit array"]
    #[doc = " @param bitSize: size in int of the bit arrays \\a bitSrc and \\a bitDst"]
    #[doc = " @param table: where to write the indirection table for the"]
    #[doc = " destination DBM, \\a dbmDst. If bit \\a i is set in the bitDst, then"]
    #[doc = " table[i] gives the index used in the \\a dbmDst."]
    #[doc = ""]
    #[doc = " @return dimDst = dimension of dbmDst."]
    #[doc = " @pre let maxDim = bitSize * 32:"]
    #[doc = " - dbmDst is at least a raw_t[resultDim*resultDim] where"]
    #[doc = "   resultDim = base_countBitsN(bitDst, bitSize)"]
    #[doc = " - dimSrc = number of bits set in bitSrc"]
    #[doc = " - bitSrc and bitDst are uint32_t[bitSize]"]
    #[doc = " - table is at least a uint32_t[maxDim]"]
    #[doc = " - bitSize <= bits2intsize(maxDim)"]
    #[doc = " - dimSrc > 0"]
    #[doc = " - first bit in bitSrc is set"]
    #[doc = " - first bit in bitDst is set"]
    #[doc = " - bitSrc and bitDst are different (contents):"]
    #[doc = "   the function is supposed to be called only"]
    #[doc = "   if there is work to do"]
    #[doc = " - dbmSrc != dbmDst (pointers): we do not"]
    #[doc = "   modify the source DBM"]
    #[doc = " - bitSize > 0 because at least ref clock"]
    #[doc = " @post"]
    #[doc = " - dimDst (returned) == number of bits in bitDst"]
    #[doc = " - for all bits set in bitDst at positions i,"]
    #[doc = "   then table[i] is defined and gives the proper"]
    #[doc = "   indirection ; for other bits, table[i] is"]
    #[doc = "   untouched."]
    pub fn dbm_shrinkExpand(
        dbmSrc: *const raw_t,
        dbmDst: *mut raw_t,
        dimSrc: cindex_t,
        bitSrc: *const u32,
        bitDst: *const u32,
        bitSize: size_t,
        table: *mut cindex_t,
    ) -> cindex_t;
}
extern "C" {
    #[doc = " Variant of dbm_shrinkExpand: Instead of giving"]
    #[doc = " bit arrays, you provide one array of the clocks"]
    #[doc = " you want in the destination."]
    #[doc = " @param dbmDst, dimDst: destination DBM of dimension dimDst"]
    #[doc = " @param dbmSrc, dimSrc: source DBM of dimension dimSrc"]
    #[doc = " @param cols: indirection table to copy the DBM, ie,"]
    #[doc = " rows (and columns) i of the destination come from"]
    #[doc = " cols[i] in the source if ~cols[i] (ie != ~0)."]
    #[doc = " @pre cols is a cindex_t[dimDst], cols[0] is ignored"]
    #[doc = " since the ref clock is always at 0, and"]
    #[doc = " for all i < dimDst: cols[i] < dimSrc."]
    pub fn dbm_updateDBM(
        dbmDst: *mut raw_t,
        dbmSrc: *const raw_t,
        dimDst: cindex_t,
        dimSrc: cindex_t,
        cols: *const cindex_t,
    );
}
extern "C" {
    #[doc = " Swap clocks."]
    #[doc = " @param dbm,dim: DBM of dimension dim."]
    #[doc = " @param x,y: clocks to swap."]
    pub fn dbm_swapClocks(dbm: *mut raw_t, dim: cindex_t, x: cindex_t, y: cindex_t);
}
extern "C" {
    #[doc = " Test if the diagonal is correct."]
    #[doc = " Constraints on the diagonal should be <0 if the"]
    #[doc = " DBM is empty or <=0 for non empty DBMs. Positive"]
    #[doc = " constraints are allowed in principle but such DBMs"]
    #[doc = " are not canonical."]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @return TRUE if the diagonal <=0."]
    pub fn dbm_isDiagonalOK(dbm: *const raw_t, dim: cindex_t) -> BOOL;
}
extern "C" {
    #[doc = " Test if"]
    #[doc = " - dbm is closed"]
    #[doc = " - dbm is not empty"]
    #[doc = " - constraints in the 1st row are at most <=0"]
    pub fn dbm_isValid(dbm: *const raw_t, dim: cindex_t) -> BOOL;
}
extern "C" {
    #[doc = " Convert code to string."]
    #[doc = " @param rel: relation result to translate."]
    #[doc = " @return string to print."]
    #[doc = " DO NOT deallocate or touch the result string."]
    pub fn dbm_relation2string(rel: relation_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Go through a DBM (dim*dim) and"]
    #[doc = " compute the max range needed to store"]
    #[doc = " the constraints, excluding infinity."]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @return max range, positive value."]
    pub fn dbm_getMaxRange(dbm: *const raw_t, dim: cindex_t) -> raw_t;
}
#[doc = " Allocator function."]
#[doc = " @param intSize: size to allocate in ints"]
#[doc = " @param data: custom data for the allocator"]
#[doc = " (ignored for malloc, for example, important"]
#[doc = "  for a custom allocator)"]
#[doc = " @return int32_t[intSize]"]
pub type allocator_f = ::std::option::Option<
    unsafe extern "C" fn(intSize: size_t, data: *mut ::std::os::raw::c_void) -> *mut i32,
>;
#[doc = " Deallocator function."]
#[doc = " @param mem: memory to deallocate"]
#[doc = " @param intSize: size to deallocate in ints"]
#[doc = " @param data: custom data for the allocator"]
#[doc = " @pre intSize must correspond to the allocated"]
#[doc = " size, mem != NULL."]
pub type deallocator_f = ::std::option::Option<
    unsafe extern "C" fn(
        mem: *mut ::std::os::raw::c_void,
        intSize: size_t,
        data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Allocator = allocator function + custom data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct allocator_t {
    pub allocData: *mut ::std::os::raw::c_void,
    pub allocFunction: allocator_f,
    pub deallocFunction: deallocator_f,
}
#[test]
fn bindgen_test_layout_allocator_t() {
    assert_eq!(
        ::std::mem::size_of::<allocator_t>(),
        24usize,
        concat!("Size of: ", stringify!(allocator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<allocator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(allocator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<allocator_t>())).allocData as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(allocator_t),
            "::",
            stringify!(allocData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<allocator_t>())).allocFunction as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(allocator_t),
            "::",
            stringify!(allocFunction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<allocator_t>())).deallocFunction as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(allocator_t),
            "::",
            stringify!(deallocFunction)
        )
    );
}
#[doc = " Style typedef: to make the difference clear"]
#[doc = " between just allocated memory and the minimal"]
#[doc = " graph representation."]
pub type mingraph_t = *const i32;
extern "C" {
    #[doc = " Save a DBM in minimal representation."]
    #[doc = ""]
    #[doc = " The API supports allocation of larger data structures than needed"]
    #[doc = " for the actual zone representation. When the \\a offset argument is"]
    #[doc = " bigger than zero, \\a offset extra integers are allocated and the"]
    #[doc = " zone is written with the given offset. Thus when \\c"]
    #[doc = " int32_t[data_size] is needed to represent the reduced zone, an \\c"]
    #[doc = " int32_t array of size \\c offset+data_size\\c is allocated. The"]
    #[doc = " first \\a offset elements can be used by the caller. It is important"]
    #[doc = " to notice that the other functions typically expect a pointer to"]
    #[doc = " the actual zone data and not to the beginning of the allocated"]
    #[doc = " block. Thus in the following piece of code, most functions expect"]
    #[doc = " \\c mg and not \\c memory:"]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = " int32_t *memory = dbm_writeToMinDBMWithOffset(...);"]
    #[doc = " mingraph_t mg = &memory[offset];"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " \\b NOTES:"]
    #[doc = " - if \\a offset is 0 and \\a dim is 1, NULL may be returned."]
    #[doc = "   NULL is valid as an input to the other functions."]
    #[doc = " - it could be possible to send as argument the maximal"]
    #[doc = "   value of the constraints that can be deduced from"]
    #[doc = "   the maximal constants but this would tie the algorithm"]
    #[doc = "   to the extrapolation."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param dbm: the DBM to save."]
    #[doc = " @param dim: its dimension."]
    #[doc = " @param minimizeGraph: activate minimized graph"]
    #[doc = " reduction. If it is FALSE, then the DBM is copied"]
    #[doc = " without its diagonal."]
    #[doc = " @param tryConstraints16: flag to try to save"]
    #[doc = " constraints on 16 bits, will cost dim*dim time."]
    #[doc = " @param c_alloc: C allocator wrapper"]
    #[doc = " @param offset: offset for allocation."]
    #[doc = " @return allocated memory."]
    #[doc = " @pre"]
    #[doc = " - dbm is a raw_t[dim*dim]"]
    #[doc = " - allocFunction allocates memory in integer units"]
    #[doc = " - dbm is closed."]
    #[doc = " - dim > 0 (at least ref clock)"]
    #[doc = " @post the returned memory is of size offset+something"]
    #[doc = "  unknown from the caller point of view."]
    pub fn dbm_writeToMinDBMWithOffset(
        dbm: *const raw_t,
        dim: cindex_t,
        minimizeGraph: BOOL,
        tryConstraints16: BOOL,
        c_alloc: allocator_t,
        offset: size_t,
    ) -> *mut i32;
}
extern "C" {
    #[doc = " Save a pre-analyzed DBM in minimal representation."]
    #[doc = " @param dbm: the DBM to save."]
    #[doc = " @param dim: its dimension."]
    #[doc = " @param bitMatrix: bit matrix resulting from the"]
    #[doc = " analysis (ie dbm_analyzeForMinDBM)."]
    #[doc = " @param nbConstraints: number of constraints in the"]
    #[doc = " bit matrix."]
    #[doc = " @param tryConstraints16: flag to try to save"]
    #[doc = " constraints on 16 bits, will cost dim*dim time."]
    #[doc = " @param allocFunction: the allocation function."]
    #[doc = " @param offset: offset for allocation."]
    #[doc = " @return allocated memory."]
    #[doc = " @pre"]
    #[doc = " - dbm is a raw_t[dim*dim]"]
    #[doc = " - allocFunction allocates memory in integer units"]
    #[doc = " - dbm is closed."]
    #[doc = " - dim > 0 (at least ref clock)"]
    #[doc = " - bitMatrix != NULL, obtained from dbm_analyzeForMinDBM"]
    #[doc = " - nbConstraints = number of bits set in bitMatrix"]
    #[doc = " - bitMatrix is a uint32_t[bits2intsize(dim*dim)]"]
    #[doc = " @post"]
    #[doc = " - the returned memory is of size offset+something"]
    #[doc = "   unknown from the caller point of view."]
    #[doc = " - bitMatrix is cleaned from the constraints xi >= 0"]
    pub fn dbm_writeAnalyzedDBM(
        dbm: *const raw_t,
        dim: cindex_t,
        bitMatrix: *mut u32,
        nbConstraints: size_t,
        tryConstraints16: BOOL,
        c_alloc: allocator_t,
        offset: size_t,
    ) -> *mut i32;
}
extern "C" {
    #[doc = " Analyze a DBM for its minimal graph representation. Computes the"]
    #[doc = " smallest number of constraints needed to represent the same zone as"]
    #[doc = " the full DBM in \\a dbm. The result in returned in \\a bitMatrix: If"]
    #[doc = " the bit \\f$ i \\cdot dim + j\\f$ is set, then the constraint"]
    #[doc = " \\f$(i,j)\\f$ of \\a dbm is needed."]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @param bitMatrix: bit matrix."]
    #[doc = " @return"]
    #[doc = " - number of needed constraints to save"]
    #[doc = " - bit matrix that marks which constraints belong to the minimal graph"]
    #[doc = " @pre bitMatrix is a uint32_t[bits2intsize(dim*dim)]"]
    pub fn dbm_analyzeForMinDBM(dbm: *const raw_t, dim: cindex_t, bitMatrix: *mut u32) -> size_t;
}
extern "C" {
    #[doc = " @return TRUE if the mingraph contains zero, FALSE otherwise."]
    pub fn dbm_mingraphHasZero(ming: mingraph_t) -> BOOL;
}
extern "C" {
    #[doc = " This is a post-processing function for dbm_analyzeForMinDBM"]
    #[doc = " to remove constraints of the form x>=0 that are part of the"]
    #[doc = " minimal graph but that do not give much information."]
    #[doc = " @param dbm,dim: DBM of dimension dim"]
    #[doc = " @param bitMatrix: bit matrix (already computed minimal graph)"]
    #[doc = " @param nbConstraints: the number of constraints of the minimal graph."]
    #[doc = " @return the updated number of constraints of the modified minimal"]
    #[doc = " graph where constraints x>=0 may have been removed."]
    #[doc = " @pre dbm_analyzeForMinDBM has been called before and nbConstraints"]
    #[doc = " corresponds to the number of constraints of the minimal graph."]
    pub fn dbm_cleanBitMatrix(
        dbm: *const raw_t,
        dim: cindex_t,
        bitMatrix: *mut u32,
        nbConstraints: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Get back the minimal graph from the internal representation."]
    #[doc = " It might be the case that the minimal graph is recomputed if"]
    #[doc = " the DBM was copied."]
    #[doc = " @param ming: internal representation of the minimal graph."]
    #[doc = " @param bitMatrix: bit matrix of the minimal graph to write."]
    #[doc = " @param isUnpacked: says if buffer contains the unpacked DBM already."]
    #[doc = " @param buffer: where to uncompress the full DBM if needed."]
    #[doc = " @return the number of constraints part of the minimal graph."]
    #[doc = " @pre let dim be the dimension of ming, bitMatrix is a uint32_t[bit2intsize(dim*dim)],"]
    #[doc = " buffer is a raw_t[dim*dim], and if isUnpacked is true then buffer contains"]
    #[doc = " the full DBM of ming."]
    #[doc = " @post if ming is the result of saving a given dbm A, then the resulting"]
    #[doc = " bitMatrix is the same as the one given by dbm_analyzeForMinDBM(A,dim,bitMatrix)"]
    #[doc = " + buffer always contains the unpacked mingraph."]
    pub fn dbm_getBitMatrixFromMinDBM(
        bitMatrix: *mut u32,
        ming: mingraph_t,
        isUnpacked: BOOL,
        buffer: *mut raw_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Convert a bit matrix marking constraints to an array of indices."]
    #[doc = " Encoding: i[k] = (index[k] & 0xffff) and j[k] = (index[k] >> 16)"]
    #[doc = " @param bitMatrix: the bit matrix to convert."]
    #[doc = " @param nbConstraints: number of set bit in the matrix."]
    #[doc = " @param index: the index array to write."]
    #[doc = " @param dim: dimension of the bit matrix."]
    #[doc = " @pre index is a indexij_t[dim*(dim-1)] and bits on the"]
    #[doc = " diagonal are not marked, nbConstraints <= dim*(dim-1)."]
    pub fn dbm_bitMatrix2indices(
        bitMatrix: *const u32,
        nbConstraints: size_t,
        index: *mut u32,
        dim: cindex_t,
    );
}
extern "C" {
    #[doc = " Read a DBM from its minimal DBM representation."]
    #[doc = " @param dbm: where to write."]
    #[doc = " @param minDBM: the minimal representation to read from."]
    #[doc = " @pre"]
    #[doc = " - dbm is a raw_t[dim*dim] where dim = dbm_getDimOfMinDBM(minDBM)"]
    #[doc = " - minDBM points to the data of the minDBM directly. There is no"]
    #[doc = "   offset."]
    #[doc = " @return dimension of DBM and unpacked DBM in dbm."]
    pub fn dbm_readFromMinDBM(dbm: *mut raw_t, minDBM: mingraph_t) -> cindex_t;
}
extern "C" {
    #[doc = " Dimension of a DBM from its packed minimal representation."]
    #[doc = " @param minDBM: the minimal DBM data directly, without offset."]
    #[doc = " @return dimension of DBM."]
    pub fn dbm_getDimOfMinDBM(minDBM: mingraph_t) -> cindex_t;
}
extern "C" {
    #[doc = " Size of the representation of the MinDBM."]
    #[doc = " This is the size of the allocated memory (without offset) for the"]
    #[doc = " minimal representation. It is at most dim*(dim-1)+1 because in the"]
    #[doc = " worst case the DBM is copied without its diagonal and we need one"]
    #[doc = " integer to store the size."]
    #[doc = " @param minDBM: minimal DBM representation (without offset)."]
    #[doc = " @return size in int32_t allocated for the representation."]
    #[doc = " NOTE: the write function allocates exactly"]
    #[doc = " int32_t[offset+dbm_getSizeOfMinDBM(minDBM)]"]
    pub fn dbm_getSizeOfMinDBM(minDBM: mingraph_t) -> size_t;
}
extern "C" {
    #[doc = " Equality test with a full DBM."]
    #[doc = " Unfortunately, this may be expensive (dim^3) if the"]
    #[doc = " minimal graph format is used."]
    #[doc = " @param dbm: full DBM."]
    #[doc = " @param dim: dimension of dbm."]
    #[doc = " @param minDBM: minimal DBM representation (without offset)."]
    #[doc = " @pre dbm is a raw_t[dim*dim] and dim > 0 (at least ref clock)"]
    #[doc = " @return TRUE if the DBMs are the same, FALSE otherwise."]
    pub fn dbm_isEqualToMinDBM(dbm: *const raw_t, dim: cindex_t, minDBM: mingraph_t) -> BOOL;
}
extern "C" {
    #[doc = " Equality test with a full DBM."]
    #[doc = " This variant of the equality test may be used if the"]
    #[doc = " DBM has already been analyzed or if you need to reuse"]
    #[doc = " the result of the analysis."]
    #[doc = " @param dbm: full DBM."]
    #[doc = " @param dim: dimension of dbm."]
    #[doc = " @param bitMatrix: bit matrix resulting from the analysis"]
    #[doc = " of dbm (dbm_analyzeforMinDBM)."]
    #[doc = " @param nbConstraints: number of constraints marked in"]
    #[doc = " the bit matrix = number of bits set."]
    #[doc = " @param minDBM: minimal DBM representation (without offset)."]
    #[doc = " @pre"]
    #[doc = " - dbm is a raw_t[dim*dim] and dim > 0 (at least ref clock)"]
    #[doc = " - bitMatrix is a uint32_t[bits2intsize(dim*dim)]"]
    #[doc = " @return TRUE if the DBMs are the same, FALSE otherwise."]
    #[doc = " @post the bitMatrix may have the bits for the constraints on"]
    #[doc = " the 1st row cleaned and nbConstraints will be updated accordingly."]
    pub fn dbm_isAnalyzedDBMEqualToMinDBM(
        dbm: *const raw_t,
        dim: cindex_t,
        bitMatrix: *mut u32,
        nbConstraints: *mut size_t,
        minDBM: mingraph_t,
    ) -> BOOL;
}
extern "C" {
    #[doc = " Another variant for equality checking:"]
    #[doc = " this one may unpack the minimal graph if needed."]
    #[doc = " It needs a buffer as an input to do so."]
    #[doc = " @param dbm, dim: full DBM of dimension dim."]
    #[doc = " @param minDBM: minimal DBM representation (without offset)."]
    #[doc = " @param buffer: buffer to unpack the DBM if needed"]
    #[doc = " @pre"]
    #[doc = " - dbm is a raw_t[dim*dim] and dim > 0 (at leat ref clock)"]
    #[doc = " - buffer != NULL is a raw_t[dim*dim]"]
    #[doc = " @post"]
    #[doc = " - buffer may be written or not. If you want to know"]
    #[doc = "   it, you can set buffer[0] = 0, and test afterwards"]
    #[doc = "   if buffer[0] == 0. If mingraph is unpacked then it"]
    #[doc = "   is guaranteed that buffer[0] == dbm_LE_ZERO, otherwise"]
    #[doc = "   buffer is untouched."]
    #[doc = " @return TRUE if the DBMs are the same, FALSE otherwise."]
    pub fn dbm_isUnpackedEqualToMinDBM(
        dbm: *const raw_t,
        dim: cindex_t,
        minDBM: mingraph_t,
        buffer: *mut raw_t,
    ) -> BOOL;
}
extern "C" {
    #[doc = " Relation between a full DBM and a minimal representation"]
    #[doc = " DBM. The relation may be exact or not:"]
    #[doc = " if the relation is exact then"]
    #[doc = "   dbm_EQUAL is returned if dbm == minDBM"]
    #[doc = "   dbm_SUBSET is returned if dbm < minDBM"]
    #[doc = "   dbm_SUPERSET is returned if dbm > minDBM"]
    #[doc = "   dbm_DIFFERENT is returned if dbm not comparable with minDBM"]
    #[doc = " else"]
    #[doc = "   dbm_SUBSET is returned if dbm <= minDBM"]
    #[doc = "   dbm_DIFFERENT otherwise"]
    #[doc = ""]
    #[doc = " @param dbm: full DBM to test."]
    #[doc = " @param dim: its dimension."]
    #[doc = " @param minDBM: minimal DBM representation."]
    #[doc = " @param unpackBuffer: memory space to unpack."]
    #[doc = "  if unpackBuffer == NULL then the relation is not exact"]
    #[doc = "  if unpackBuffer != NULL then assume that buffer = raw_t[dim*dim]"]
    #[doc = "  to be able to unpack the DBM and compute an exact relation."]
    #[doc = ""]
    #[doc = " NOTE: unpackBuffer is sent as an argument to avoid stackoverflow"]
    #[doc = " if using stack allocation. The needed size is in dim*dim*sizeof(int)."]
    #[doc = " It is NOT guaranteed that unpackBuffer will be written. The dbm"]
    #[doc = " MAY be unpacked only if relation != subset and unpackBuffer != NULL."]
    #[doc = ""]
    #[doc = " @pre"]
    #[doc = " - dbm is closed and not empty"]
    #[doc = " - dbm is a raw_t[dim*dim] (full DBM)"]
    #[doc = " - dim > 0 (at least ref clock)"]
    #[doc = " @return relation as described above."]
    pub fn dbm_relationWithMinDBM(
        dbm: *const raw_t,
        dim: cindex_t,
        minDBM: mingraph_t,
        unpackBuffer: *mut raw_t,
    ) -> relation_t;
}
extern "C" {
    #[doc = " Variant of the previous relation function."]
    #[doc = " This may be cheaper if what count is to know"]
    #[doc = " (subset or equal) or different or superset."]
    #[doc = " if unpackBuffer != NULL then"]
    #[doc = "   dbm_EQUAL or dbm_SUBSET is returned if dbm == minDBM"]
    #[doc = "   dbm_SUBSET is returned if dbm < minDBM"]
    #[doc = "   dbm_SUPERSET is returned if dbm > minDBM"]
    #[doc = "   dbm_DIFFERENT is returned if dbm not comparable with minDBM"]
    #[doc = " else"]
    #[doc = "   dbm_SUBSET is returned if dbm <= minDBM"]
    #[doc = "   dbm_DIFFERENT is returned otherwise"]
    #[doc = ""]
    #[doc = " @param dbm: full DBM to test."]
    #[doc = " @param dim: its dimension."]
    #[doc = " @param minDBM: minimal DBM representation."]
    #[doc = " @param unpackBuffer: memory space to unpack."]
    #[doc = "  if unpackBuffer == NULL then the relation is not exact"]
    #[doc = "  if unpackBuffer != NULL then assume that buffer = raw_t[dim*dim]"]
    #[doc = "  to be able to unpack the DBM and compute an exact relation."]
    #[doc = " @pre"]
    #[doc = " - dbm is closed and not empty"]
    #[doc = " - dbm is a raw_t[dim*dim] (full DBM)"]
    #[doc = " - dim > 0 (at least ref clock)"]
    #[doc = " @return relation as described above."]
    pub fn dbm_approxRelationWithMinDBM(
        dbm: *const raw_t,
        dim: cindex_t,
        minDBM: mingraph_t,
        unpackBuffer: *mut raw_t,
    ) -> relation_t;
}
extern "C" {
    #[doc = " Convex union."]
    #[doc = " This may cost dim^3 in time since the minimal DBM has"]
    #[doc = " to be unpacked to a full DBM."]
    #[doc = " Computes dbm = dbm + minDBM"]
    #[doc = " @param dbm: dbm to make the union with."]
    #[doc = " @param dim: its dimension."]
    #[doc = " @param minDBM: minDBM to add to dbm (without offset)."]
    #[doc = " @param unpackBuffer: memory space to unpack the DBM."]
    #[doc = " @pre"]
    #[doc = " - dbm is a raw_t[dim*dim] and dim > 0 (at least ref clock)."]
    #[doc = " - DBMs have the same dimensions"]
    #[doc = " - unpackBuffer != NULL and is a raw_t[dim*dim]"]
    pub fn dbm_convexUnionWithMinDBM(
        dbm: *mut raw_t,
        dim: cindex_t,
        minDBM: mingraph_t,
        unpackBuffer: *mut raw_t,
    );
}
#[doc = "< only clock ref, dim == 1"]
pub const representationOfMinDBM_t_dbm_MINDBM_TRIVIAL: representationOfMinDBM_t = 0;
#[doc = "< 32 bits, dbm copy without diagonal"]
pub const representationOfMinDBM_t_dbm_MINDBM_COPY32: representationOfMinDBM_t = 1;
#[doc = "< 32 bits, c_ij and a bit matrix"]
pub const representationOfMinDBM_t_dbm_MINDBM_BITMATRIX32: representationOfMinDBM_t = 2;
#[doc = "< 32 bits, c_ij and tuples (i,j)"]
pub const representationOfMinDBM_t_dbm_MINDBM_TUPLES32: representationOfMinDBM_t = 3;
#[doc = "< 16 bits, dbm copy without diagonal"]
pub const representationOfMinDBM_t_dbm_MINDBM_COPY16: representationOfMinDBM_t = 4;
#[doc = "< 16 bits, c_ij and a bit matrix"]
pub const representationOfMinDBM_t_dbm_MINDBM_BITMATRIX16: representationOfMinDBM_t = 5;
#[doc = "< 16 bits, c_ij and tuples (i,j)"]
pub const representationOfMinDBM_t_dbm_MINDBM_TUPLES16: representationOfMinDBM_t = 6;
#[doc = "< should never be the case"]
pub const representationOfMinDBM_t_dbm_MINDBM_ERROR: representationOfMinDBM_t = 7;
#[doc = " Simple type to allow for statistics on the different internal"]
#[doc = " formats used. The format are not user controllable and should"]
#[doc = " not be read from outside. For the tuple representation, it is"]
#[doc = " not said here if it is (i,j,c_ij) or a bunch of c_ij and (i,j)."]
pub type representationOfMinDBM_t = u32;
extern "C" {
    #[doc = " @return the type of the internal format used."]
    #[doc = " @param minDBM: minimal representation (without offset)"]
    #[doc = " to read."]
    pub fn dbm_getRepresentationType(minDBM: mingraph_t) -> representationOfMinDBM_t;
}
#[repr(C)]
#[derive(Debug)]
pub struct dbm_ClockAccessor {
    pub _base: base_Object,
}
#[test]
fn bindgen_test_layout_dbm_ClockAccessor() {
    assert_eq!(
        ::std::mem::size_of::<dbm_ClockAccessor>(),
        16usize,
        concat!("Size of: ", stringify!(dbm_ClockAccessor))
    );
    assert_eq!(
        ::std::mem::align_of::<dbm_ClockAccessor>(),
        8usize,
        concat!("Alignment of ", stringify!(dbm_ClockAccessor))
    );
}
extern "C" {
    #[link_name = "\u{1}ClockAccessor_destructor"]
    pub fn dbm_ClockAccessor_ClockAccessor_destructor(this: *mut dbm_ClockAccessor);
}
#[doc = " Valuation: like a fixed vector of scalars S with"]
#[doc = " some basic operations on it."]
#[doc = " We don't use array_t because we don't want to"]
#[doc = " resize but we need basic memory alloc/dealloc."]
#[repr(C)]
#[derive(Debug)]
pub struct dbm_Valuation<S> {
    pub _base: base_pointer_t<S>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<S>>,
}
#[doc = " IntValuation = Valuation<int32_t>"]
pub type dbm_IntValuation = dbm_Valuation<i32>;
#[doc = " DoubleValuation = Valuation<double>"]
pub type dbm_DoubleValuation = dbm_Valuation<f64>;
#[doc = " Wrapper class for clock operations, @see dbm_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dbm_ClockOperation<TYPE> {
    pub ptr: *mut TYPE,
    #[doc = " related dbm_t or fed_t, no reference count"]
    pub clock: cindex_t,
    #[doc = " clock to read/write"]
    pub incVal: i32,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<TYPE>>,
}
#[doc = " dbm_t: DBM type. A DBM is basically a matrix of dimension >= 1,"]
#[doc = " ALWAYS >= 1."]
#[doc = ""]
#[doc = " Special features:"]
#[doc = ""]
#[doc = " - sharing of DBMs (intern()): a cheap way to save memory"]
#[doc = "   for DBMs that are to be kept but not modified is to share"]
#[doc = "   identical DBMs (by using a hash table internally). Different"]
#[doc = "   dbm_t may point to the same idbm_t data. Another effect of"]
#[doc = "   this call is that if 2 dbm_t have had their intern() methods"]
#[doc = "   called, then test for equality is reduced to pointer testing,"]
#[doc = "   which is provided by the sameAs method."]
#[doc = ""]
#[doc = " - direct access to the DBM matrix: read-only access is"]
#[doc = "   straight-forward (with the () operator). Read-write access"]
#[doc = "   (getDBM()) is more subtle because there may be no DBM allocated or"]
#[doc = "   the internal DBM may be shared with another dbm_t. Furthermore,"]
#[doc = "   the invariant of dbm_t is that it has a DBM matrix iff it is"]
#[doc = "   closed and non empty. Thus, when asking for a read-write"]
#[doc = "   direct access, we may need to allocate and copy internally."]
#[doc = "   After the direct access, the invariant must also hold."]
#[doc = "   Direct access must not be mixed with accessing the original"]
#[doc = "   dbm_t in case the matrix is deallocated for some reason."]
#[doc = ""]
#[doc = " - relation with fed_t (the federation type): relation(xx) and"]
#[doc = "   the operators == != < > ... have the semantics of set inclusion"]
#[doc = "   check with DBMs pair-wise. These relations are exact when a"]
#[doc = "   dbm_t is compared with a dbm_t but are approximate when a dbm_t"]
#[doc = "   is compared with a fed_t, since the semantics is DBM inclusion"]
#[doc = "   check! We do not detect if a union of DBM is equal (semantically"]
#[doc = "   with respect to sets) to another DBM with the relation(xx) methods"]
#[doc = "   and < > <= .. operators. The (semantic) exact relation is provided"]
#[doc = "   by the exactRelation(xx) and le lt ge.. methods. The results from"]
#[doc = "   the approximate relations are safe, in the sense that EQUAL, SUBSET,"]
#[doc = "   and SUPERSET are reliable. However, DIFFERENT could be refined, we"]
#[doc = "   don't know. This is enough for most cases. The special case"]
#[doc = "   dbm_t >= fed_t is an exact comparison."]
#[doc = ""]
#[doc = " - the closed form is maintained internally."]
#[doc = ""]
#[doc = " - interaction with \"raw matrices\" is supported, ie, it is possible"]
#[doc = "   to use DBMs as arrays raw_t[dim*dim] where dim is the dimension"]
#[doc = "   of the DBMs. However, in these cases, it is assumed that these"]
#[doc = "   DBMs are valid, which is, dbm_isValid(dbm, dim) holds."]
#[doc = ""]
#[doc = " - convenient operations:"]
#[doc = "   Assume you have declared dbm_t a,b;"]
#[doc = "   then you can write the following expressions:"]
#[doc = "   a(2) = a(3) + 3; is the clock update x2 = x3 + 3 for the DBM a"]
#[doc = "   a(1) = 0; is the clock update value (also called reset) x1 = 0"]
#[doc = "   a(1) += 3; is the clock increment x1 += 3"]
#[doc = "   b &= dbm_t(a(2) + 2); is the intersection of the result of"]
#[doc = "   x2 += 2 in for the DBM a and b (though a is not changed)."]
#[doc = "   if (a(2) < a(1) + 2) tests if the clock constraint x2 < x1 + 2 holds"]
#[doc = "   with respect to the DBM a."]
#[doc = "   See the interface of ClockOperation."]
#[doc = "   IMPORTANT: YOU ARE NOT SUPPOSED TO USE dbm_t::ClockOperation EXPLICITELY"]
#[doc = "   like declaring dbm_t::ClockOperation = .. and hack with it: this would"]
#[doc = "   give wrong results because of how + and - are implemented. This"]
#[doc = "   is kept simple here for efficiency and simplicity and"]
#[doc = "   let the compiler do its magic and optimize the final compiled"]
#[doc = "   inlined expressions!"]
#[doc = ""]
#[repr(C)]
#[derive(Debug)]
pub struct dbm_dbm_t {
    #[doc = " Internal pointer or special coding for empty."]
    pub idbmPtr: *mut dbm_idbm_t,
}
pub const dbm_dbm_t_MAX_DIM_POWER: dbm_dbm_t__bindgen_ty_1 = 15;
pub const dbm_dbm_t_MAX_DIM: dbm_dbm_t__bindgen_ty_1 = 32767;
pub type dbm_dbm_t__bindgen_ty_1 = u32;
#[test]
fn bindgen_test_layout_dbm_dbm_t() {
    assert_eq!(
        ::std::mem::size_of::<dbm_dbm_t>(),
        8usize,
        concat!("Size of: ", stringify!(dbm_dbm_t))
    );
    assert_eq!(
        ::std::mem::align_of::<dbm_dbm_t>(),
        8usize,
        concat!("Alignment of ", stringify!(dbm_dbm_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dbm_dbm_t>())).idbmPtr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dbm_dbm_t),
            "::",
            stringify!(idbmPtr)
        )
    );
}
extern "C" {
    #[doc = " @return the dimension of this DBM."]
    #[link_name = "\u{1}getDimension"]
    pub fn dbm_dbm_t_getDimension(this: *const dbm_dbm_t) -> cindex_t;
}
extern "C" {
    #[doc = " @return string representation of the"]
    #[doc = " constraints of this DBM. A clock"]
    #[doc = " is always positive, so \"true\" simply means"]
    #[doc = " all clocks positive."]
    #[link_name = "\u{1}toString"]
    pub fn dbm_dbm_t_toString(this: *const dbm_dbm_t, arg1: *const dbm_ClockAccessor)
        -> std_string;
}
extern "C" {
    #[doc = " Make an unbounded DBM with the lower bounds set to low"]
    #[doc = " (strict constraints)."]
    #[link_name = "\u{1}makeUnbounded"]
    pub fn dbm_dbm_t_makeUnbounded(low: *const i32, dim: cindex_t) -> dbm_dbm_t;
}
extern "C" {
    #[doc = " Wrapper for dbm_getSizeOfMinDBM. Here for other compatibility reasons."]
    #[doc = " @pre dimension == getDimension()"]
    #[link_name = "\u{1}getSizeOfMinDBM"]
    pub fn dbm_dbm_t_getSizeOfMinDBM(dim: cindex_t, arg1: mingraph_t) -> size_t;
}
extern "C" {
    #[doc = " Construct a dbm_t from a mingraph_t. Not as a constructor"]
    #[doc = " for other compatibility reasons."]
    #[doc = " @pre dimension == getDimension()"]
    #[link_name = "\u{1}readFromMinDBM"]
    pub fn dbm_dbm_t_readFromMinDBM(dim: cindex_t, arg1: mingraph_t) -> dbm_dbm_t;
}
extern "C" {
    #[doc = " Change the dimension of this DBM."]
    #[doc = " The resulting DBM is empty. @post isEmpty()"]
    #[link_name = "\u{1}setDimension"]
    pub fn dbm_dbm_t_setDimension(this: *mut dbm_dbm_t, dim: cindex_t);
}
extern "C" {
    #[doc = " @return true if it is empty."]
    #[link_name = "\u{1}isEmpty"]
    pub fn dbm_dbm_t_isEmpty(this: *const dbm_dbm_t) -> bool;
}
extern "C" {
    #[doc = " Empty this DBM."]
    #[link_name = "\u{1}setEmpty"]
    pub fn dbm_dbm_t_setEmpty(this: *mut dbm_dbm_t);
}
extern "C" {
    #[doc = " Short for setDimension(1), has the effect of deallocating the DBM."]
    #[link_name = "\u{1}nil"]
    pub fn dbm_dbm_t_nil(this: *mut dbm_dbm_t);
}
extern "C" {
    #[doc = " @return true if this DBM contains the zero point."]
    #[link_name = "\u{1}hasZero"]
    pub fn dbm_dbm_t_hasZero(this: *const dbm_dbm_t) -> bool;
}
extern "C" {
    #[doc = " @return a hash value."]
    #[link_name = "\u{1}hash"]
    pub fn dbm_dbm_t_hash(this: *const dbm_dbm_t, seed: u32) -> u32;
}
extern "C" {
    #[doc = " @return true if arg has the same internal idbmPtr."]
    #[link_name = "\u{1}sameAs"]
    pub fn dbm_dbm_t_sameAs(this: *const dbm_dbm_t, arg: *const dbm_dbm_t) -> bool;
}
extern "C" {
    #[doc = " Try to share the DBM."]
    #[link_name = "\u{1}intern"]
    pub fn dbm_dbm_t_intern(this: *mut dbm_dbm_t);
}
extern "C" {
    #[doc = " Copy from a DBM."]
    #[link_name = "\u{1}copyFrom"]
    pub fn dbm_dbm_t_copyFrom(this: *mut dbm_dbm_t, src: *const raw_t, dim: cindex_t);
}
extern "C" {
    #[doc = " Copy to a DBM."]
    #[doc = " @pre dbm_isValid(dst, dim) and dim == getDimension()"]
    #[link_name = "\u{1}copyTo"]
    pub fn dbm_dbm_t_copyTo(this: *const dbm_dbm_t, dst: *mut raw_t, dim: cindex_t);
}
extern "C" {
    #[doc = " @return a read-write access pointer to the internal DBM."]
    #[doc = " @post return non null pointer iff getDimension() > 0"]
    #[link_name = "\u{1}getDBM"]
    pub fn dbm_dbm_t_getDBM(this: *mut dbm_dbm_t) -> *mut raw_t;
}
extern "C" {
    #[doc = " Compute the minimal set of constraints to represent"]
    #[doc = " this DBM."]
    #[doc = " @see dbm_analyzeForMinDBM."]
    #[doc = " @return the number of constraints of the set."]
    #[doc = " @pre bitMatrix is a uint32_t[bits2intsize(dim*dim)] and !isEmpty()"]
    #[link_name = "\u{1}analyzeForMinDBM"]
    pub fn dbm_dbm_t_analyzeForMinDBM(this: *const dbm_dbm_t, bitMatrix: *mut u32) -> size_t;
}
extern "C" {
    #[doc = " Compute & save the minimal set of constraints."]
    #[doc = " @param tryConstraints16: flag to try to save"]
    #[doc = " constraints on 16 bits, will cost dim*dim time."]
    #[doc = " @param c_alloc: C allocator wrapper"]
    #[doc = " @param offset: offset for allocation."]
    #[doc = " @return allocated memory."]
    #[doc = " @pre !isEmpty()."]
    #[link_name = "\u{1}writeToMinDBMWithOffset"]
    pub fn dbm_dbm_t_writeToMinDBMWithOffset(
        this: *const dbm_dbm_t,
        minimizeGraph: bool,
        tryConstraints16: bool,
        c_alloc: allocator_t,
        offset: size_t,
    ) -> *mut i32;
}
extern "C" {
    #[doc = " Similar to writeToMinDBMWithOffset but works with"]
    #[doc = " a pre-analyzed DBM."]
    #[doc = " @pre !isEmpty() and bitMatrix corresponds to its"]
    #[doc = " analysis (otherwise nonsense will be written)."]
    #[doc = " @see dbm_writeAnalyzedDBM."]
    #[doc = " @post bitMatrix is cleaned from the constraints xi>=0."]
    #[link_name = "\u{1}writeAnalyzedDBM"]
    pub fn dbm_dbm_t_writeAnalyzedDBM(
        this: *const dbm_dbm_t,
        bitMatrix: *mut u32,
        nbConstraints: size_t,
        tryConstraints16: BOOL,
        c_alloc: allocator_t,
        offset: size_t,
    ) -> *mut i32;
}
extern "C" {
    #[doc = " Relation with a mingraph_t, @see dbm_relationWithMinDBM."]
    #[doc = " @pre unpackBuffer is a raw_t[dim*dim]."]
    #[link_name = "\u{1}relation"]
    pub fn dbm_dbm_t_relation(
        this: *const dbm_dbm_t,
        ming: mingraph_t,
        unpackBuffer: *mut raw_t,
    ) -> relation_t;
}
extern "C" {
    #[doc = " Relation (wrt inclusion, approximate only for fed_t)."]
    #[doc = " @return this (relation) arg."]
    #[link_name = "\u{1}relation"]
    pub fn dbm_dbm_t_relation1(this: *const dbm_dbm_t, arg: *const dbm_dbm_t) -> relation_t;
}
extern "C" {
    #[link_name = "\u{1}relation"]
    pub fn dbm_dbm_t_relation2(this: *const dbm_dbm_t, arg: *const dbm_fed_t) -> relation_t;
}
extern "C" {
    #[link_name = "\u{1}relation"]
    pub fn dbm_dbm_t_relation3(
        this: *const dbm_dbm_t,
        arg: *const raw_t,
        dim: cindex_t,
    ) -> relation_t;
}
extern "C" {
    #[doc = " Exact (expensive) relations (for fed_t only)."]
    #[link_name = "\u{1}lt"]
    pub fn dbm_dbm_t_lt(this: *const dbm_dbm_t, arg: *const dbm_fed_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}gt"]
    pub fn dbm_dbm_t_gt(this: *const dbm_dbm_t, arg: *const dbm_fed_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}le"]
    pub fn dbm_dbm_t_le(this: *const dbm_dbm_t, arg: *const dbm_fed_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}ge"]
    pub fn dbm_dbm_t_ge(this: *const dbm_dbm_t, arg: *const dbm_fed_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}eq"]
    pub fn dbm_dbm_t_eq(this: *const dbm_dbm_t, arg: *const dbm_fed_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}exactRelation"]
    pub fn dbm_dbm_t_exactRelation(this: *const dbm_dbm_t, arg: *const dbm_fed_t) -> relation_t;
}
extern "C" {
    #[doc = " Set this zone to zero (origin)."]
    #[doc = " @param tau: tau clock, @see dbm.h"]
    #[doc = " @post !isEmpty() iff dim > 0."]
    #[link_name = "\u{1}setZero"]
    pub fn dbm_dbm_t_setZero(this: *mut dbm_dbm_t) -> *mut dbm_dbm_t;
}
extern "C" {
    #[doc = " (re-)initialize the DBM with no constraint."]
    #[doc = " @post !isEmpty() iff dim > 0."]
    #[link_name = "\u{1}setInit"]
    pub fn dbm_dbm_t_setInit(this: *mut dbm_dbm_t) -> *mut dbm_dbm_t;
}
extern "C" {
    #[doc = " @return dbm_isEqualToInit(DBM), @see dbm.h"]
    #[link_name = "\u{1}isInit"]
    pub fn dbm_dbm_t_isInit(this: *const dbm_dbm_t) -> bool;
}
extern "C" {
    #[doc = " @return dbm_isEqualToZero(DBM), @see dbm.h"]
    #[link_name = "\u{1}isZero"]
    pub fn dbm_dbm_t_isZero(this: *const dbm_dbm_t) -> bool;
}
extern "C" {
    #[doc = " Computes the biggest lower cost in the zone."]
    #[doc = "  This corresponds to the value"]
    #[doc = "  \\f$\\sup\\{ c \\mid \\exists v \\in Z : c ="]
    #[doc = "  \\inf \\{ c' \\mid v[cost\\mapsto c'] \\in Z \\} \\}\\f$"]
    #[link_name = "\u{1}getUpperMinimumCost"]
    pub fn dbm_dbm_t_getUpperMinimumCost(this: *const dbm_dbm_t, cost: i32) -> i32;
}
extern "C" {
    #[doc = " Only for compatibility with priced DBMs."]
    #[link_name = "\u{1}getInfimum"]
    pub fn dbm_dbm_t_getInfimum(this: *const dbm_dbm_t) -> i32;
}
extern "C" {
    #[doc = " Compute the intersection with the axis of a given clock."]
    #[doc = " @return !isEmpty()"]
    #[link_name = "\u{1}intersectionAxis"]
    pub fn dbm_dbm_t_intersectionAxis(this: *mut dbm_dbm_t, arg1: cindex_t) -> bool;
}
extern "C" {
    #[doc = " Methods for constraining: with one or more constraints."]
    #[doc = " Variants with @param table: indirection table for the indices."]
    #[doc = " - clock xi == value"]
    #[doc = " - clocks xi-xj < cij or <= cij (constraint = c)"]
    #[doc = " - clocks xi-xj < or <= b depending on strictness (strictness_t or bool)."]
    #[doc = " - or several constraints at once."]
    #[doc = " @pre compatible indices, i != j for the constraints, and"]
    #[doc = " table is an cindex_t[getDimension()]"]
    #[doc = " @return !isEmpty()"]
    #[link_name = "\u{1}constrain"]
    pub fn dbm_dbm_t_constrain(this: *mut dbm_dbm_t, i: cindex_t, value: i32) -> bool;
}
extern "C" {
    #[link_name = "\u{1}constrain"]
    pub fn dbm_dbm_t_constrain1(this: *mut dbm_dbm_t, i: cindex_t, j: cindex_t, c: raw_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}constrain"]
    pub fn dbm_dbm_t_constrain2(
        this: *mut dbm_dbm_t,
        i: cindex_t,
        j: cindex_t,
        b: i32,
        s: strictness_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}constrain"]
    pub fn dbm_dbm_t_constrain3(
        this: *mut dbm_dbm_t,
        i: cindex_t,
        j: cindex_t,
        b: i32,
        isStrict: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}constrain"]
    pub fn dbm_dbm_t_constrain4(this: *mut dbm_dbm_t, c: *const constraint_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}constrain"]
    pub fn dbm_dbm_t_constrain5(this: *mut dbm_dbm_t, c: *const constraint_t, n: size_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}constrain"]
    pub fn dbm_dbm_t_constrain6(
        this: *mut dbm_dbm_t,
        table: *const cindex_t,
        c: *const constraint_t,
        n: size_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}constrain"]
    pub fn dbm_dbm_t_constrain7(
        this: *mut dbm_dbm_t,
        table: *const cindex_t,
        arg1: *const base_pointer_t<constraint_t>,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}constrain"]
    pub fn dbm_dbm_t_constrain8(
        this: *mut dbm_dbm_t,
        table: *const cindex_t,
        arg1: *const [u64; 3usize],
    ) -> bool;
}
extern "C" {
    #[doc = " @return false if there is no intersection with the argument"]
    #[doc = " or true if there *may* be an intersection."]
    #[doc = " @pre same dimension."]
    #[link_name = "\u{1}intersects"]
    pub fn dbm_dbm_t_intersects(this: *const dbm_dbm_t, arg1: *const dbm_dbm_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}intersects"]
    pub fn dbm_dbm_t_intersects1(this: *const dbm_dbm_t, arg1: *const dbm_fed_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}intersects"]
    pub fn dbm_dbm_t_intersects2(this: *const dbm_dbm_t, arg1: *const raw_t, dim: cindex_t)
        -> bool;
}
extern "C" {
    #[doc = " Delay (strongest post-condition). Remove upper bounds."]
    #[doc = " @return this"]
    #[link_name = "\u{1}up"]
    pub fn dbm_dbm_t_up(this: *mut dbm_dbm_t) -> *mut dbm_dbm_t;
}
extern "C" {
    #[doc = " Delay, except for stopped clocks."]
    #[doc = " @param stopped is a bit array marking which clocks are stopped."]
    #[doc = " @pre if stopped != NULL then it is a uint32_t[bits2intsize(getDimension())]."]
    #[link_name = "\u{1}upStop"]
    pub fn dbm_dbm_t_upStop(this: *mut dbm_dbm_t, stopped: *const u32) -> *mut dbm_dbm_t;
}
extern "C" {
    #[doc = " Inverse delay (weakest pre-condition). Remove lower bounds."]
    #[doc = " @return this"]
    #[link_name = "\u{1}down"]
    pub fn dbm_dbm_t_down(this: *mut dbm_dbm_t) -> *mut dbm_dbm_t;
}
extern "C" {
    #[doc = " Similar to upStop but for inverse delay."]
    #[link_name = "\u{1}downStop"]
    pub fn dbm_dbm_t_downStop(this: *mut dbm_dbm_t, stopped: *const u32) -> *mut dbm_dbm_t;
}
extern "C" {
    #[doc = " Free clock (unconstrain). Remove constraints on a particular"]
    #[doc = " clock, both upper and lower bounds."]
    #[doc = " @return this. @post freeClock(c) == freeUp(c).freeDown(c)"]
    #[link_name = "\u{1}freeClock"]
    pub fn dbm_dbm_t_freeClock(this: *mut dbm_dbm_t, clock: cindex_t) -> *mut dbm_dbm_t;
}
extern "C" {
    #[doc = " Free upper or lower bounds only for a particular clock or"]
    #[doc = " for all clocks. @pre 0 < clock < getDimension()"]
    #[doc = " @return this. @see dbm.h"]
    #[link_name = "\u{1}freeUp"]
    pub fn dbm_dbm_t_freeUp(this: *mut dbm_dbm_t, clock: cindex_t) -> *mut dbm_dbm_t;
}
extern "C" {
    #[link_name = "\u{1}freeDown"]
    pub fn dbm_dbm_t_freeDown(this: *mut dbm_dbm_t, clock: cindex_t) -> *mut dbm_dbm_t;
}
extern "C" {
    #[link_name = "\u{1}freeAllUp"]
    pub fn dbm_dbm_t_freeAllUp(this: *mut dbm_dbm_t) -> *mut dbm_dbm_t;
}
extern "C" {
    #[link_name = "\u{1}freeAllDown"]
    pub fn dbm_dbm_t_freeAllDown(this: *mut dbm_dbm_t) -> *mut dbm_dbm_t;
}
extern "C" {
    #[doc = " Update methods where x & y are clocks, v an integer value."]
    #[doc = " x := v     -> updateValue"]
    #[doc = " x := y     -> updateClock"]
    #[doc = " x := x + v -> updateIncrement"]
    #[doc = " x := y + v -> update"]
    #[doc = " @pre 0 < x and y < getDimension(), v < infinity, and v is"]
    #[doc = " s.t. the clocks stay positive."]
    #[link_name = "\u{1}updateValue"]
    pub fn dbm_dbm_t_updateValue(this: *mut dbm_dbm_t, x: cindex_t, v: i32);
}
extern "C" {
    #[link_name = "\u{1}updateClock"]
    pub fn dbm_dbm_t_updateClock(this: *mut dbm_dbm_t, x: cindex_t, y: cindex_t);
}
extern "C" {
    #[link_name = "\u{1}updateIncrement"]
    pub fn dbm_dbm_t_updateIncrement(this: *mut dbm_dbm_t, x: cindex_t, v: i32);
}
extern "C" {
    #[link_name = "\u{1}update"]
    pub fn dbm_dbm_t_update(this: *mut dbm_dbm_t, x: cindex_t, y: cindex_t, v: i32);
}
extern "C" {
    #[doc = " Check if the DBM satisfies a constraint c_ij."]
    #[doc = " @pre i != j, i and j < getDimension()"]
    #[link_name = "\u{1}satisfies"]
    pub fn dbm_dbm_t_satisfies(this: *const dbm_dbm_t, i: cindex_t, j: cindex_t, c: raw_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}satisfies"]
    pub fn dbm_dbm_t_satisfies1(this: *const dbm_dbm_t, c: *const constraint_t) -> bool;
}
extern "C" {
    #[doc = " @return true if this DBM contains points that can delay arbitrarily."]
    #[link_name = "\u{1}isUnbounded"]
    pub fn dbm_dbm_t_isUnbounded(this: *const dbm_dbm_t) -> bool;
}
extern "C" {
    #[doc = " Make upper or lower finite bounds non strict."]
    #[doc = " @see dbm.h."]
    #[doc = " @return this."]
    #[link_name = "\u{1}relaxUp"]
    pub fn dbm_dbm_t_relaxUp(this: *mut dbm_dbm_t) -> *mut dbm_dbm_t;
}
extern "C" {
    #[link_name = "\u{1}relaxDown"]
    pub fn dbm_dbm_t_relaxDown(this: *mut dbm_dbm_t) -> *mut dbm_dbm_t;
}
extern "C" {
    #[doc = " Make lower bounds strict."]
    #[doc = " @return this."]
    #[link_name = "\u{1}tightenDown"]
    pub fn dbm_dbm_t_tightenDown(this: *mut dbm_dbm_t) -> *mut dbm_dbm_t;
}
extern "C" {
    #[doc = " Make upper bounds strict."]
    #[doc = " @return this."]
    #[link_name = "\u{1}tightenUp"]
    pub fn dbm_dbm_t_tightenUp(this: *mut dbm_dbm_t) -> *mut dbm_dbm_t;
}
extern "C" {
    #[doc = " Similar for all bounds of a particular clock."]
    #[doc = " @see dbm.h. Special for clock == 0:"]
    #[doc = " relaxUp(0) = relaxDown() and relaxDown(0) = relaxUp()."]
    #[link_name = "\u{1}relaxUpClock"]
    pub fn dbm_dbm_t_relaxUpClock(this: *mut dbm_dbm_t, clock: cindex_t) -> *mut dbm_dbm_t;
}
extern "C" {
    #[link_name = "\u{1}relaxDownClock"]
    pub fn dbm_dbm_t_relaxDownClock(this: *mut dbm_dbm_t, clock: cindex_t) -> *mut dbm_dbm_t;
}
extern "C" {
    #[doc = " Make all constraints (except infinity) non strict."]
    #[link_name = "\u{1}relaxAll"]
    pub fn dbm_dbm_t_relaxAll(this: *mut dbm_dbm_t) -> *mut dbm_dbm_t;
}
extern "C" {
    #[doc = " Test point inclusion."]
    #[doc = " @pre same dimension."]
    #[link_name = "\u{1}contains"]
    pub fn dbm_dbm_t_contains(this: *const dbm_dbm_t, point: *const dbm_IntValuation) -> bool;
}
extern "C" {
    #[link_name = "\u{1}contains"]
    pub fn dbm_dbm_t_contains1(this: *const dbm_dbm_t, point: *const i32, dim: cindex_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}contains"]
    pub fn dbm_dbm_t_contains2(this: *const dbm_dbm_t, point: *const dbm_DoubleValuation) -> bool;
}
extern "C" {
    #[link_name = "\u{1}contains"]
    pub fn dbm_dbm_t_contains3(this: *const dbm_dbm_t, point: *const f64, dim: cindex_t) -> bool;
}
extern "C" {
    #[doc = " Compute the 'almost min' necessary delay from"]
    #[doc = " a point to enter this federation. If this point"]
    #[doc = " is already contained in this federation, 0.0 is"]
    #[doc = " returned. The result is 'almost min' since we"]
    #[doc = " want a discrete value, which is not possible in"]
    #[doc = " case of strict constraints."]
    #[doc = " @pre dim == getDimension() and point[0] == 0.0"]
    #[doc = " otherwise the computation will not work."]
    #[doc = " @return true if it is possible to reach this DBM"]
    #[doc = " by delaying, or false if this DBM is empty or it"]
    #[doc = " is not possible to reach it by delaying."]
    #[doc = " The delay is written in t."]
    #[doc = " @param minVal,minStrict: another (optional) output"]
    #[doc = " is provided in the form of a delay value and a"]
    #[doc = " flag telling if the delay is strict, e.g.,"]
    #[doc = " wait >= 2.1 or wait > 2.1."]
    #[doc = " @pre minVal and minStrict are both NULL or non NULL."]
    #[link_name = "\u{1}getMinDelay"]
    pub fn dbm_dbm_t_getMinDelay(
        this: *const dbm_dbm_t,
        point: *const dbm_DoubleValuation,
        t: *mut f64,
        minVal: *mut f64,
        minStrict: *mut bool,
        stopped: *const u32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}getMinDelay"]
    pub fn dbm_dbm_t_getMinDelay1(
        this: *const dbm_dbm_t,
        point: *const f64,
        dim: cindex_t,
        t: *mut f64,
        minVal: *mut f64,
        minStrict: *mut bool,
        stopped: *const u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Compute the max delay from a point such that it respects the"]
    #[doc = " upper bound constraints of the DBM."]
    #[doc = " @return true if the delay is possible, false otherwise."]
    #[link_name = "\u{1}getMaxDelay"]
    pub fn dbm_dbm_t_getMaxDelay(
        this: *const dbm_dbm_t,
        point: *const dbm_DoubleValuation,
        t: *mut f64,
        minVal: *mut f64,
        minStrict: *mut bool,
        stopped: *const u32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}getMaxDelay"]
    pub fn dbm_dbm_t_getMaxDelay1(
        this: *const dbm_dbm_t,
        point: *const f64,
        dim: cindex_t,
        t: *mut f64,
        minVal: *mut f64,
        minStrict: *mut bool,
        stopped: *const u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Similarly for the past."]
    #[doc = "  The returned value (in t) is <= max."]
    #[doc = "  @pre max > 0 otherwise this is meaningless."]
    #[link_name = "\u{1}getMaxBackDelay"]
    pub fn dbm_dbm_t_getMaxBackDelay(
        this: *const dbm_dbm_t,
        point: *const dbm_DoubleValuation,
        t: *mut f64,
        max: f64,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}getMaxBackDelay"]
    pub fn dbm_dbm_t_getMaxBackDelay1(
        this: *const dbm_dbm_t,
        point: *const f64,
        dim: cindex_t,
        t: *mut f64,
        max: f64,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}isConstrainedBy"]
    pub fn dbm_dbm_t_isConstrainedBy(
        this: *const dbm_dbm_t,
        arg1: cindex_t,
        arg2: cindex_t,
        arg3: raw_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Extrapolations: @see dbm_##method functions in dbm.h."]
    #[doc = " @pre max, lower, and upper are int32_t[getDimension()]"]
    #[link_name = "\u{1}extrapolateMaxBounds"]
    pub fn dbm_dbm_t_extrapolateMaxBounds(this: *mut dbm_dbm_t, max: *const i32);
}
extern "C" {
    #[link_name = "\u{1}diagonalExtrapolateMaxBounds"]
    pub fn dbm_dbm_t_diagonalExtrapolateMaxBounds(this: *mut dbm_dbm_t, max: *const i32);
}
extern "C" {
    #[link_name = "\u{1}extrapolateLUBounds"]
    pub fn dbm_dbm_t_extrapolateLUBounds(
        this: *mut dbm_dbm_t,
        lower: *const i32,
        upper: *const i32,
    );
}
extern "C" {
    #[link_name = "\u{1}diagonalExtrapolateLUBounds"]
    pub fn dbm_dbm_t_diagonalExtrapolateLUBounds(
        this: *mut dbm_dbm_t,
        lower: *const i32,
        upper: *const i32,
    );
}
extern "C" {
    #[doc = " Resize this DBM: bitSrc marks the subset of clocks (out from"]
    #[doc = " a larger total set) that are in this DBM and bitDst marks the"]
    #[doc = " subset of clocks we want to change to. Resizing means keep the"]
    #[doc = " constraints of the clocks that are kept, remove the constraints"]
    #[doc = " of the clocks that are removed, and add free constraints (infinity)"]
    #[doc = " for the new clocks."]
    #[doc = " @see dbm_shrinkExpand in dbm.h."]
    #[doc = " @param bitSrc,bitDst,bitSize: bit strings of (int) size bitSize"]
    #[doc = " that mark the source and destination active clocks."]
    #[doc = " @param table: redirection table to write."]
    #[doc = " @pre bitSrc & bitDst are uint32_t[bitSize] and"]
    #[doc = " table is a uint32_t[32*bitSize]"]
    #[doc = " @post the indirection table is written."]
    #[link_name = "\u{1}resize"]
    pub fn dbm_dbm_t_resize(
        this: *mut dbm_dbm_t,
        bitSrc: *const u32,
        bitDst: *const u32,
        bitSize: size_t,
        table: *mut cindex_t,
    );
}
extern "C" {
    #[doc = " Resize and change clocks of this DBM."]
    #[doc = " The updated DBM will have its clocks i coming from target[i]"]
    #[doc = " in the original DBM."]
    #[doc = " @param target is the table that says where to put the current"]
    #[doc = " clocks in the target DBM. If target[i] = ~0 then a new free"]
    #[doc = " clock is inserted."]
    #[doc = " @pre newDim > 0, target is a cindex_t[newDim], and"]
    #[doc = " for all i < newDim, target[i] < getDimension()."]
    #[link_name = "\u{1}changeClocks"]
    pub fn dbm_dbm_t_changeClocks(this: *mut dbm_dbm_t, target: *const cindex_t, newDim: cindex_t);
}
extern "C" {
    #[doc = " Swap clocks x and y."]
    #[link_name = "\u{1}swapClocks"]
    pub fn dbm_dbm_t_swapClocks(this: *mut dbm_dbm_t, x: cindex_t, y: cindex_t);
}
extern "C" {
    #[doc = " Get a clock valuation and change only the clocks"]
    #[doc = " that are marked free."]
    #[doc = " @param cval: clock valuation to write."]
    #[doc = " @param freeC: free clocks to write. If freeC = NULL then all"]
    #[doc = " clocks are considered free."]
    #[doc = " @return cval"]
    #[doc = " @throw std::out_of_range if the generation fails"]
    #[doc = " if isEmpty() or cval too constrained."]
    #[doc = " @post if freeC != NULL, forall i < dim: freeC[i] = false"]
    #[link_name = "\u{1}getValuation"]
    pub fn dbm_dbm_t_getValuation(
        this: *const dbm_dbm_t,
        cval: *mut dbm_DoubleValuation,
        freeC: *mut bool,
    ) -> *mut dbm_DoubleValuation;
}
extern "C" {
    #[doc = " @return (this-arg).isEmpty() but it is able to"]
    #[doc = " stop the subtraction early if it is not empty and"]
    #[doc = " it does not modify itself."]
    #[doc = " @pre same dimension."]
    #[link_name = "\u{1}isSubtractionEmpty"]
    pub fn dbm_dbm_t_isSubtractionEmpty(
        this: *const dbm_dbm_t,
        arg: *const raw_t,
        dim: cindex_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}isSubtractionEmpty"]
    pub fn dbm_dbm_t_isSubtractionEmpty1(this: *const dbm_dbm_t, arg: *const dbm_fed_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}isSubtractionEmpty"]
    pub fn dbm_dbm_t_isSubtractionEmpty2(this: *const dbm_dbm_t, arg: *const dbm_dbm_t) -> bool;
}
extern "C" {
    #[doc = " Simplified copy with @pre isEmpty()"]
    #[link_name = "\u{1}newCopy"]
    pub fn dbm_dbm_t_newCopy(this: *mut dbm_dbm_t, arg: *const raw_t, dim: cindex_t);
}
extern "C" {
    #[doc = " Simplified copy with @pre isEmpty() && !arg.isEmpty()"]
    #[link_name = "\u{1}newCopy"]
    pub fn dbm_dbm_t_newCopy1(this: *mut dbm_dbm_t, arg: *const dbm_dbm_t);
}
extern "C" {
    #[doc = " Simplified copy with @pre !isEmpty()"]
    #[link_name = "\u{1}updateCopy"]
    pub fn dbm_dbm_t_updateCopy(this: *mut dbm_dbm_t, arg: *const raw_t, dim: cindex_t);
}
extern "C" {
    #[doc = " Simplified copy with @pre !isEmpty() && !arg.isEmpty()"]
    #[link_name = "\u{1}updateCopy"]
    pub fn dbm_dbm_t_updateCopy1(this: *mut dbm_dbm_t, arg: *const dbm_dbm_t);
}
extern "C" {
    #[doc = " Const access to its idbm_t, @pre !isEmpty()"]
    #[link_name = "\u{1}const_idbmt"]
    pub fn dbm_dbm_t_const_idbmt(this: *const dbm_dbm_t) -> *const dbm_idbm_t;
}
extern "C" {
    #[doc = " @return idbmPtr as a pointer @pre !isEmpty()"]
    #[link_name = "\u{1}idbmt"]
    pub fn dbm_dbm_t_idbmt(this: *mut dbm_dbm_t) -> *mut dbm_idbm_t;
}
extern "C" {
    #[doc = " Explicit const access to the DBM matrix."]
    #[doc = " Note: const_dbm() and dbm() have different assertions."]
    #[doc = " @pre !isEmpty()"]
    #[link_name = "\u{1}const_dbm"]
    pub fn dbm_dbm_t_const_dbm(this: *const dbm_dbm_t) -> *const raw_t;
}
extern "C" {
    #[doc = " Mutable access to the DBM matrix."]
    #[doc = " @pre isMutable()"]
    #[link_name = "\u{1}dbm"]
    pub fn dbm_dbm_t_dbm(this: *mut dbm_dbm_t) -> *mut raw_t;
}
extern "C" {
    #[doc = " @return dimension with @pre isEmpty()"]
    #[link_name = "\u{1}edim"]
    pub fn dbm_dbm_t_edim(this: *const dbm_dbm_t) -> cindex_t;
}
extern "C" {
    #[doc = " @return dimension with @pre !isEmpty()"]
    #[link_name = "\u{1}pdim"]
    pub fn dbm_dbm_t_pdim(this: *const dbm_dbm_t) -> cindex_t;
}
extern "C" {
    #[doc = " @return true if this fed_t can be modified, @pre isPointer()"]
    #[link_name = "\u{1}isMutable"]
    pub fn dbm_dbm_t_isMutable(this: *const dbm_dbm_t) -> bool;
}
extern "C" {
    #[doc = " Set and return a new writable DBM, @pre !isEmpty()"]
    #[link_name = "\u{1}getNew"]
    pub fn dbm_dbm_t_getNew(this: *mut dbm_dbm_t) -> *mut raw_t;
}
extern "C" {
    #[doc = " Set and return a writable copy of this DBM, @pre !isEmpty()"]
    #[link_name = "\u{1}getCopy"]
    pub fn dbm_dbm_t_getCopy(this: *mut dbm_dbm_t) -> *mut raw_t;
}
extern "C" {
    #[doc = " Initialize a dbm_t to empty DBM of a given dimension."]
    #[doc = " @param dim: dimension of the DBM."]
    #[doc = " @post isEmpty()"]
    #[link_name = "\u{1}dbm_t"]
    pub fn dbm_dbm_t_dbm_t(this: *mut dbm_dbm_t, dim: cindex_t);
}
extern "C" {
    #[doc = " Standard copy constructor."]
    #[link_name = "\u{1}dbm_t"]
    pub fn dbm_dbm_t_dbm_t1(this: *mut dbm_dbm_t, arg: *const dbm_dbm_t);
}
extern "C" {
    #[doc = " Copy constructor from a DBM matrix."]
    #[doc = " @post isEmpty() iff dim == 0"]
    #[link_name = "\u{1}dbm_t"]
    pub fn dbm_dbm_t_dbm_t2(this: *mut dbm_dbm_t, arg: *const raw_t, dim: cindex_t);
}
extern "C" {
    #[doc = " Special constructor to copy the result of a pending operation."]
    #[doc = " @param op: clock operation."]
    #[link_name = "\u{1}dbm_t"]
    pub fn dbm_dbm_t_dbm_t3(this: *mut dbm_dbm_t, op: *const dbm_ClockOperation<dbm_dbm_t>);
}
extern "C" {
    #[link_name = "\u{1}dbm_t_destructor"]
    pub fn dbm_dbm_t_dbm_t_destructor(this: *mut dbm_dbm_t);
}
impl dbm_dbm_t {
    #[inline]
    pub unsafe fn getDimension(&self) -> cindex_t {
        dbm_dbm_t_getDimension(self)
    }
    #[inline]
    pub unsafe fn toString(&self, arg1: *const dbm_ClockAccessor) -> std_string {
        dbm_dbm_t_toString(self, arg1)
    }
    #[inline]
    pub unsafe fn makeUnbounded(low: *const i32, dim: cindex_t) -> dbm_dbm_t {
        dbm_dbm_t_makeUnbounded(low, dim)
    }
    #[inline]
    pub unsafe fn getSizeOfMinDBM(dim: cindex_t, arg1: mingraph_t) -> size_t {
        dbm_dbm_t_getSizeOfMinDBM(dim, arg1)
    }
    #[inline]
    pub unsafe fn readFromMinDBM(dim: cindex_t, arg1: mingraph_t) -> dbm_dbm_t {
        dbm_dbm_t_readFromMinDBM(dim, arg1)
    }
    #[inline]
    pub unsafe fn setDimension(&mut self, dim: cindex_t) {
        dbm_dbm_t_setDimension(self, dim)
    }
    #[inline]
    pub unsafe fn isEmpty(&self) -> bool {
        dbm_dbm_t_isEmpty(self)
    }
    #[inline]
    pub unsafe fn setEmpty(&mut self) {
        dbm_dbm_t_setEmpty(self)
    }
    #[inline]
    pub unsafe fn nil(&mut self) {
        dbm_dbm_t_nil(self)
    }
    #[inline]
    pub unsafe fn hasZero(&self) -> bool {
        dbm_dbm_t_hasZero(self)
    }
    #[inline]
    pub unsafe fn hash(&self, seed: u32) -> u32 {
        dbm_dbm_t_hash(self, seed)
    }
    #[inline]
    pub unsafe fn sameAs(&self, arg: *const dbm_dbm_t) -> bool {
        dbm_dbm_t_sameAs(self, arg)
    }
    #[inline]
    pub unsafe fn intern(&mut self) {
        dbm_dbm_t_intern(self)
    }
    #[inline]
    pub unsafe fn copyFrom(&mut self, src: *const raw_t, dim: cindex_t) {
        dbm_dbm_t_copyFrom(self, src, dim)
    }
    #[inline]
    pub unsafe fn copyTo(&self, dst: *mut raw_t, dim: cindex_t) {
        dbm_dbm_t_copyTo(self, dst, dim)
    }
    #[inline]
    pub unsafe fn getDBM(&mut self) -> *mut raw_t {
        dbm_dbm_t_getDBM(self)
    }
    #[inline]
    pub unsafe fn analyzeForMinDBM(&self, bitMatrix: *mut u32) -> size_t {
        dbm_dbm_t_analyzeForMinDBM(self, bitMatrix)
    }
    #[inline]
    pub unsafe fn writeToMinDBMWithOffset(
        &self,
        minimizeGraph: bool,
        tryConstraints16: bool,
        c_alloc: allocator_t,
        offset: size_t,
    ) -> *mut i32 {
        dbm_dbm_t_writeToMinDBMWithOffset(self, minimizeGraph, tryConstraints16, c_alloc, offset)
    }
    #[inline]
    pub unsafe fn writeAnalyzedDBM(
        &self,
        bitMatrix: *mut u32,
        nbConstraints: size_t,
        tryConstraints16: BOOL,
        c_alloc: allocator_t,
        offset: size_t,
    ) -> *mut i32 {
        dbm_dbm_t_writeAnalyzedDBM(
            self,
            bitMatrix,
            nbConstraints,
            tryConstraints16,
            c_alloc,
            offset,
        )
    }
    #[inline]
    pub unsafe fn relation(&self, ming: mingraph_t, unpackBuffer: *mut raw_t) -> relation_t {
        dbm_dbm_t_relation(self, ming, unpackBuffer)
    }
    #[inline]
    pub unsafe fn relation1(&self, arg: *const dbm_dbm_t) -> relation_t {
        dbm_dbm_t_relation1(self, arg)
    }
    #[inline]
    pub unsafe fn relation2(&self, arg: *const dbm_fed_t) -> relation_t {
        dbm_dbm_t_relation2(self, arg)
    }
    #[inline]
    pub unsafe fn relation3(&self, arg: *const raw_t, dim: cindex_t) -> relation_t {
        dbm_dbm_t_relation3(self, arg, dim)
    }
    #[inline]
    pub unsafe fn lt(&self, arg: *const dbm_fed_t) -> bool {
        dbm_dbm_t_lt(self, arg)
    }
    #[inline]
    pub unsafe fn gt(&self, arg: *const dbm_fed_t) -> bool {
        dbm_dbm_t_gt(self, arg)
    }
    #[inline]
    pub unsafe fn le(&self, arg: *const dbm_fed_t) -> bool {
        dbm_dbm_t_le(self, arg)
    }
    #[inline]
    pub unsafe fn ge(&self, arg: *const dbm_fed_t) -> bool {
        dbm_dbm_t_ge(self, arg)
    }
    #[inline]
    pub unsafe fn eq(&self, arg: *const dbm_fed_t) -> bool {
        dbm_dbm_t_eq(self, arg)
    }
    #[inline]
    pub unsafe fn exactRelation(&self, arg: *const dbm_fed_t) -> relation_t {
        dbm_dbm_t_exactRelation(self, arg)
    }
    #[inline]
    pub unsafe fn setZero(&mut self) -> *mut dbm_dbm_t {
        dbm_dbm_t_setZero(self)
    }
    #[inline]
    pub unsafe fn setInit(&mut self) -> *mut dbm_dbm_t {
        dbm_dbm_t_setInit(self)
    }
    #[inline]
    pub unsafe fn isInit(&self) -> bool {
        dbm_dbm_t_isInit(self)
    }
    #[inline]
    pub unsafe fn isZero(&self) -> bool {
        dbm_dbm_t_isZero(self)
    }
    #[inline]
    pub unsafe fn getUpperMinimumCost(&self, cost: i32) -> i32 {
        dbm_dbm_t_getUpperMinimumCost(self, cost)
    }
    #[inline]
    pub unsafe fn getInfimum(&self) -> i32 {
        dbm_dbm_t_getInfimum(self)
    }
    #[inline]
    pub unsafe fn intersectionAxis(&mut self, arg1: cindex_t) -> bool {
        dbm_dbm_t_intersectionAxis(self, arg1)
    }
    #[inline]
    pub unsafe fn constrain(&mut self, i: cindex_t, value: i32) -> bool {
        dbm_dbm_t_constrain(self, i, value)
    }
    #[inline]
    pub unsafe fn constrain1(&mut self, i: cindex_t, j: cindex_t, c: raw_t) -> bool {
        dbm_dbm_t_constrain1(self, i, j, c)
    }
    #[inline]
    pub unsafe fn constrain2(&mut self, i: cindex_t, j: cindex_t, b: i32, s: strictness_t) -> bool {
        dbm_dbm_t_constrain2(self, i, j, b, s)
    }
    #[inline]
    pub unsafe fn constrain3(&mut self, i: cindex_t, j: cindex_t, b: i32, isStrict: bool) -> bool {
        dbm_dbm_t_constrain3(self, i, j, b, isStrict)
    }
    #[inline]
    pub unsafe fn constrain4(&mut self, c: *const constraint_t) -> bool {
        dbm_dbm_t_constrain4(self, c)
    }
    #[inline]
    pub unsafe fn constrain5(&mut self, c: *const constraint_t, n: size_t) -> bool {
        dbm_dbm_t_constrain5(self, c, n)
    }
    #[inline]
    pub unsafe fn constrain6(
        &mut self,
        table: *const cindex_t,
        c: *const constraint_t,
        n: size_t,
    ) -> bool {
        dbm_dbm_t_constrain6(self, table, c, n)
    }
    #[inline]
    pub unsafe fn constrain7(
        &mut self,
        table: *const cindex_t,
        arg1: *const base_pointer_t<constraint_t>,
    ) -> bool {
        dbm_dbm_t_constrain7(self, table, arg1)
    }
    #[inline]
    pub unsafe fn constrain8(
        &mut self,
        table: *const cindex_t,
        arg1: *const [u64; 3usize],
    ) -> bool {
        dbm_dbm_t_constrain8(self, table, arg1)
    }
    #[inline]
    pub unsafe fn intersects(&self, arg1: *const dbm_dbm_t) -> bool {
        dbm_dbm_t_intersects(self, arg1)
    }
    #[inline]
    pub unsafe fn intersects1(&self, arg1: *const dbm_fed_t) -> bool {
        dbm_dbm_t_intersects1(self, arg1)
    }
    #[inline]
    pub unsafe fn intersects2(&self, arg1: *const raw_t, dim: cindex_t) -> bool {
        dbm_dbm_t_intersects2(self, arg1, dim)
    }
    #[inline]
    pub unsafe fn up(&mut self) -> *mut dbm_dbm_t {
        dbm_dbm_t_up(self)
    }
    #[inline]
    pub unsafe fn upStop(&mut self, stopped: *const u32) -> *mut dbm_dbm_t {
        dbm_dbm_t_upStop(self, stopped)
    }
    #[inline]
    pub unsafe fn down(&mut self) -> *mut dbm_dbm_t {
        dbm_dbm_t_down(self)
    }
    #[inline]
    pub unsafe fn downStop(&mut self, stopped: *const u32) -> *mut dbm_dbm_t {
        dbm_dbm_t_downStop(self, stopped)
    }
    #[inline]
    pub unsafe fn freeClock(&mut self, clock: cindex_t) -> *mut dbm_dbm_t {
        dbm_dbm_t_freeClock(self, clock)
    }
    #[inline]
    pub unsafe fn freeUp(&mut self, clock: cindex_t) -> *mut dbm_dbm_t {
        dbm_dbm_t_freeUp(self, clock)
    }
    #[inline]
    pub unsafe fn freeDown(&mut self, clock: cindex_t) -> *mut dbm_dbm_t {
        dbm_dbm_t_freeDown(self, clock)
    }
    #[inline]
    pub unsafe fn freeAllUp(&mut self) -> *mut dbm_dbm_t {
        dbm_dbm_t_freeAllUp(self)
    }
    #[inline]
    pub unsafe fn freeAllDown(&mut self) -> *mut dbm_dbm_t {
        dbm_dbm_t_freeAllDown(self)
    }
    #[inline]
    pub unsafe fn updateValue(&mut self, x: cindex_t, v: i32) {
        dbm_dbm_t_updateValue(self, x, v)
    }
    #[inline]
    pub unsafe fn updateClock(&mut self, x: cindex_t, y: cindex_t) {
        dbm_dbm_t_updateClock(self, x, y)
    }
    #[inline]
    pub unsafe fn updateIncrement(&mut self, x: cindex_t, v: i32) {
        dbm_dbm_t_updateIncrement(self, x, v)
    }
    #[inline]
    pub unsafe fn update(&mut self, x: cindex_t, y: cindex_t, v: i32) {
        dbm_dbm_t_update(self, x, y, v)
    }
    #[inline]
    pub unsafe fn satisfies(&self, i: cindex_t, j: cindex_t, c: raw_t) -> bool {
        dbm_dbm_t_satisfies(self, i, j, c)
    }
    #[inline]
    pub unsafe fn satisfies1(&self, c: *const constraint_t) -> bool {
        dbm_dbm_t_satisfies1(self, c)
    }
    #[inline]
    pub unsafe fn isUnbounded(&self) -> bool {
        dbm_dbm_t_isUnbounded(self)
    }
    #[inline]
    pub unsafe fn relaxUp(&mut self) -> *mut dbm_dbm_t {
        dbm_dbm_t_relaxUp(self)
    }
    #[inline]
    pub unsafe fn relaxDown(&mut self) -> *mut dbm_dbm_t {
        dbm_dbm_t_relaxDown(self)
    }
    #[inline]
    pub unsafe fn tightenDown(&mut self) -> *mut dbm_dbm_t {
        dbm_dbm_t_tightenDown(self)
    }
    #[inline]
    pub unsafe fn tightenUp(&mut self) -> *mut dbm_dbm_t {
        dbm_dbm_t_tightenUp(self)
    }
    #[inline]
    pub unsafe fn relaxUpClock(&mut self, clock: cindex_t) -> *mut dbm_dbm_t {
        dbm_dbm_t_relaxUpClock(self, clock)
    }
    #[inline]
    pub unsafe fn relaxDownClock(&mut self, clock: cindex_t) -> *mut dbm_dbm_t {
        dbm_dbm_t_relaxDownClock(self, clock)
    }
    #[inline]
    pub unsafe fn relaxAll(&mut self) -> *mut dbm_dbm_t {
        dbm_dbm_t_relaxAll(self)
    }
    #[inline]
    pub unsafe fn contains(&self, point: *const dbm_IntValuation) -> bool {
        dbm_dbm_t_contains(self, point)
    }
    #[inline]
    pub unsafe fn contains1(&self, point: *const i32, dim: cindex_t) -> bool {
        dbm_dbm_t_contains1(self, point, dim)
    }
    #[inline]
    pub unsafe fn contains2(&self, point: *const dbm_DoubleValuation) -> bool {
        dbm_dbm_t_contains2(self, point)
    }
    #[inline]
    pub unsafe fn contains3(&self, point: *const f64, dim: cindex_t) -> bool {
        dbm_dbm_t_contains3(self, point, dim)
    }
    #[inline]
    pub unsafe fn getMinDelay(
        &self,
        point: *const dbm_DoubleValuation,
        t: *mut f64,
        minVal: *mut f64,
        minStrict: *mut bool,
        stopped: *const u32,
    ) -> bool {
        dbm_dbm_t_getMinDelay(self, point, t, minVal, minStrict, stopped)
    }
    #[inline]
    pub unsafe fn getMinDelay1(
        &self,
        point: *const f64,
        dim: cindex_t,
        t: *mut f64,
        minVal: *mut f64,
        minStrict: *mut bool,
        stopped: *const u32,
    ) -> bool {
        dbm_dbm_t_getMinDelay1(self, point, dim, t, minVal, minStrict, stopped)
    }
    #[inline]
    pub unsafe fn getMaxDelay(
        &self,
        point: *const dbm_DoubleValuation,
        t: *mut f64,
        minVal: *mut f64,
        minStrict: *mut bool,
        stopped: *const u32,
    ) -> bool {
        dbm_dbm_t_getMaxDelay(self, point, t, minVal, minStrict, stopped)
    }
    #[inline]
    pub unsafe fn getMaxDelay1(
        &self,
        point: *const f64,
        dim: cindex_t,
        t: *mut f64,
        minVal: *mut f64,
        minStrict: *mut bool,
        stopped: *const u32,
    ) -> bool {
        dbm_dbm_t_getMaxDelay1(self, point, dim, t, minVal, minStrict, stopped)
    }
    #[inline]
    pub unsafe fn getMaxBackDelay(
        &self,
        point: *const dbm_DoubleValuation,
        t: *mut f64,
        max: f64,
    ) -> bool {
        dbm_dbm_t_getMaxBackDelay(self, point, t, max)
    }
    #[inline]
    pub unsafe fn getMaxBackDelay1(
        &self,
        point: *const f64,
        dim: cindex_t,
        t: *mut f64,
        max: f64,
    ) -> bool {
        dbm_dbm_t_getMaxBackDelay1(self, point, dim, t, max)
    }
    #[inline]
    pub unsafe fn isConstrainedBy(&self, arg1: cindex_t, arg2: cindex_t, arg3: raw_t) -> bool {
        dbm_dbm_t_isConstrainedBy(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn extrapolateMaxBounds(&mut self, max: *const i32) {
        dbm_dbm_t_extrapolateMaxBounds(self, max)
    }
    #[inline]
    pub unsafe fn diagonalExtrapolateMaxBounds(&mut self, max: *const i32) {
        dbm_dbm_t_diagonalExtrapolateMaxBounds(self, max)
    }
    #[inline]
    pub unsafe fn extrapolateLUBounds(&mut self, lower: *const i32, upper: *const i32) {
        dbm_dbm_t_extrapolateLUBounds(self, lower, upper)
    }
    #[inline]
    pub unsafe fn diagonalExtrapolateLUBounds(&mut self, lower: *const i32, upper: *const i32) {
        dbm_dbm_t_diagonalExtrapolateLUBounds(self, lower, upper)
    }
    #[inline]
    pub unsafe fn resize(
        &mut self,
        bitSrc: *const u32,
        bitDst: *const u32,
        bitSize: size_t,
        table: *mut cindex_t,
    ) {
        dbm_dbm_t_resize(self, bitSrc, bitDst, bitSize, table)
    }
    #[inline]
    pub unsafe fn changeClocks(&mut self, target: *const cindex_t, newDim: cindex_t) {
        dbm_dbm_t_changeClocks(self, target, newDim)
    }
    #[inline]
    pub unsafe fn swapClocks(&mut self, x: cindex_t, y: cindex_t) {
        dbm_dbm_t_swapClocks(self, x, y)
    }
    #[inline]
    pub unsafe fn getValuation(
        &self,
        cval: *mut dbm_DoubleValuation,
        freeC: *mut bool,
    ) -> *mut dbm_DoubleValuation {
        dbm_dbm_t_getValuation(self, cval, freeC)
    }
    #[inline]
    pub unsafe fn isSubtractionEmpty(&self, arg: *const raw_t, dim: cindex_t) -> bool {
        dbm_dbm_t_isSubtractionEmpty(self, arg, dim)
    }
    #[inline]
    pub unsafe fn isSubtractionEmpty1(&self, arg: *const dbm_fed_t) -> bool {
        dbm_dbm_t_isSubtractionEmpty1(self, arg)
    }
    #[inline]
    pub unsafe fn isSubtractionEmpty2(&self, arg: *const dbm_dbm_t) -> bool {
        dbm_dbm_t_isSubtractionEmpty2(self, arg)
    }
    #[inline]
    pub unsafe fn newCopy(&mut self, arg: *const raw_t, dim: cindex_t) {
        dbm_dbm_t_newCopy(self, arg, dim)
    }
    #[inline]
    pub unsafe fn newCopy1(&mut self, arg: *const dbm_dbm_t) {
        dbm_dbm_t_newCopy1(self, arg)
    }
    #[inline]
    pub unsafe fn updateCopy(&mut self, arg: *const raw_t, dim: cindex_t) {
        dbm_dbm_t_updateCopy(self, arg, dim)
    }
    #[inline]
    pub unsafe fn updateCopy1(&mut self, arg: *const dbm_dbm_t) {
        dbm_dbm_t_updateCopy1(self, arg)
    }
    #[inline]
    pub unsafe fn const_idbmt(&self) -> *const dbm_idbm_t {
        dbm_dbm_t_const_idbmt(self)
    }
    #[inline]
    pub unsafe fn idbmt(&mut self) -> *mut dbm_idbm_t {
        dbm_dbm_t_idbmt(self)
    }
    #[inline]
    pub unsafe fn const_dbm(&self) -> *const raw_t {
        dbm_dbm_t_const_dbm(self)
    }
    #[inline]
    pub unsafe fn dbm(&mut self) -> *mut raw_t {
        dbm_dbm_t_dbm(self)
    }
    #[inline]
    pub unsafe fn edim(&self) -> cindex_t {
        dbm_dbm_t_edim(self)
    }
    #[inline]
    pub unsafe fn pdim(&self) -> cindex_t {
        dbm_dbm_t_pdim(self)
    }
    #[inline]
    pub unsafe fn isMutable(&self) -> bool {
        dbm_dbm_t_isMutable(self)
    }
    #[inline]
    pub unsafe fn getNew(&mut self) -> *mut raw_t {
        dbm_dbm_t_getNew(self)
    }
    #[inline]
    pub unsafe fn getCopy(&mut self) -> *mut raw_t {
        dbm_dbm_t_getCopy(self)
    }
    #[inline]
    pub unsafe fn new(dim: cindex_t) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        dbm_dbm_t_dbm_t(__bindgen_tmp.as_mut_ptr(), dim);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg: *const dbm_dbm_t) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        dbm_dbm_t_dbm_t1(__bindgen_tmp.as_mut_ptr(), arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg: *const raw_t, dim: cindex_t) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        dbm_dbm_t_dbm_t2(__bindgen_tmp.as_mut_ptr(), arg, dim);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(op: *const dbm_ClockOperation<dbm_dbm_t>) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        dbm_dbm_t_dbm_t3(__bindgen_tmp.as_mut_ptr(), op);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        dbm_dbm_t_dbm_t_destructor(self)
    }
}
#[doc = " fed_t: federation type."]
#[doc = ""]
#[doc = " Special features:"]
#[doc = ""]
#[doc = " - direct reference transfer: similarly to dbm_t."]
#[doc = ""]
#[doc = " - sharing of DBMs: this is a call-back for dbm_t."]
#[doc = ""]
#[doc = " - raw_t* argument must satisfy dbm_isValid(..)"]
#[doc = ""]
#[doc = " - relations: see dbm_t, the exact relation operations (wrt"]
#[doc = "   set inclusion) are exactRelation and the methods le lt gt ge eq."]
#[doc = "   Approximate relations are relation, < > <= >= == !=."]
#[doc = ""]
#[doc = " - convenient operations: like dbm_t but for all the internal"]
#[doc = "   DBMs. This is a call-back for all the dbm_t that are in fed_t."]
#[doc = ""]
#[doc = " - methods marked as dummy wrappers: these are for copy arguments."]
#[doc = "   In the cases where the compiler wants a fed_t&, it"]
#[doc = "   won't be happy to find a fed_t, so we define a number of"]
#[doc = "   dummy wrappers to make it understand that the thing on the"]
#[doc = "   stack may be taken as a reference argument too."]
#[doc = ""]
#[repr(C)]
#[derive(Debug)]
pub struct dbm_fed_t {
    pub ifedPtr: *mut dbm_ifed_t,
}
#[doc = " Mutable iterator -> iterate though dbm_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dbm_fed_t_iterator {
    pub fdbm: *mut *mut dbm_fdbm_t,
    #[doc = " list of DBMs"]
    pub ifed: *mut dbm_ifed_t,
}
extern "C" {
    #[link_name = "\u{1}ENDF"]
    pub static mut dbm_fed_t_iterator_ENDF: *const dbm_fdbm_t;
}
#[test]
fn bindgen_test_layout_dbm_fed_t_iterator() {
    assert_eq!(
        ::std::mem::size_of::<dbm_fed_t_iterator>(),
        16usize,
        concat!("Size of: ", stringify!(dbm_fed_t_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<dbm_fed_t_iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(dbm_fed_t_iterator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dbm_fed_t_iterator>())).fdbm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dbm_fed_t_iterator),
            "::",
            stringify!(fdbm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dbm_fed_t_iterator>())).ifed as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dbm_fed_t_iterator),
            "::",
            stringify!(ifed)
        )
    );
}
extern "C" {
    #[doc = " Test if there are DBMs left on the list."]
    #[link_name = "\u{1}null"]
    pub fn dbm_fed_t_iterator_null(this: *const dbm_fed_t_iterator) -> bool;
}
extern "C" {
    #[doc = " @return true if there is another DBM after, @pre !null()"]
    #[link_name = "\u{1}hasNext"]
    pub fn dbm_fed_t_iterator_hasNext(this: *const dbm_fed_t_iterator) -> bool;
}
extern "C" {
    #[doc = " Remove (and deallocate) current dbm_t."]
    #[link_name = "\u{1}remove"]
    pub fn dbm_fed_t_iterator_remove(this: *mut dbm_fed_t_iterator);
}
extern "C" {
    #[doc = " Remove (and deallocate) current empty dbm_t."]
    #[link_name = "\u{1}removeEmpty"]
    pub fn dbm_fed_t_iterator_removeEmpty(this: *mut dbm_fed_t_iterator);
}
extern "C" {
    #[doc = " Extract the current DBM from the list."]
    #[doc = " The result->getNext() points to the rest of the list."]
    #[link_name = "\u{1}extract"]
    pub fn dbm_fed_t_iterator_extract(this: *mut dbm_fed_t_iterator) -> *mut dbm_fdbm_t;
}
extern "C" {
    #[doc = " Insert a DBM in the list at the current position."]
    #[link_name = "\u{1}insert"]
    pub fn dbm_fed_t_iterator_insert(this: *mut dbm_fed_t_iterator, dbm: *mut dbm_fdbm_t);
}
extern "C" {
    #[doc = " Special constructor to end iterations."]
    #[link_name = "\u{1}iterator"]
    pub fn dbm_fed_t_iterator_iterator(this: *mut dbm_fed_t_iterator);
}
extern "C" {
    #[doc = " Initialize the iterator of a federation."]
    #[doc = " @param fed: federation."]
    #[link_name = "\u{1}iterator"]
    pub fn dbm_fed_t_iterator_iterator1(this: *mut dbm_fed_t_iterator, fed: *mut dbm_ifed_t);
}
impl dbm_fed_t_iterator {
    #[inline]
    pub unsafe fn null(&self) -> bool {
        dbm_fed_t_iterator_null(self)
    }
    #[inline]
    pub unsafe fn hasNext(&self) -> bool {
        dbm_fed_t_iterator_hasNext(self)
    }
    #[inline]
    pub unsafe fn remove(&mut self) {
        dbm_fed_t_iterator_remove(self)
    }
    #[inline]
    pub unsafe fn removeEmpty(&mut self) {
        dbm_fed_t_iterator_removeEmpty(self)
    }
    #[inline]
    pub unsafe fn extract(&mut self) -> *mut dbm_fdbm_t {
        dbm_fed_t_iterator_extract(self)
    }
    #[inline]
    pub unsafe fn insert(&mut self, dbm: *mut dbm_fdbm_t) {
        dbm_fed_t_iterator_insert(self, dbm)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        dbm_fed_t_iterator_iterator(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(fed: *mut dbm_ifed_t) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        dbm_fed_t_iterator_iterator1(__bindgen_tmp.as_mut_ptr(), fed);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " Const iterator -> iterate though dbm_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dbm_fed_t_const_iterator {
    pub fdbm: *const dbm_fdbm_t,
}
extern "C" {
    #[link_name = "\u{1}ENDI"]
    pub static dbm_fed_t_const_iterator_ENDI: dbm_fed_t_const_iterator;
}
#[test]
fn bindgen_test_layout_dbm_fed_t_const_iterator() {
    assert_eq!(
        ::std::mem::size_of::<dbm_fed_t_const_iterator>(),
        8usize,
        concat!("Size of: ", stringify!(dbm_fed_t_const_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<dbm_fed_t_const_iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(dbm_fed_t_const_iterator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dbm_fed_t_const_iterator>())).fdbm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dbm_fed_t_const_iterator),
            "::",
            stringify!(fdbm)
        )
    );
}
extern "C" {
    #[doc = " Test if there are DBMs left on the list."]
    #[link_name = "\u{1}null"]
    pub fn dbm_fed_t_const_iterator_null(this: *const dbm_fed_t_const_iterator) -> bool;
}
extern "C" {
    #[doc = " @return true if there is another DBM after, @pre !null()"]
    #[link_name = "\u{1}hasNext"]
    pub fn dbm_fed_t_const_iterator_hasNext(this: *const dbm_fed_t_const_iterator) -> bool;
}
extern "C" {
    #[doc = " Constructor: @param fed: federation."]
    #[link_name = "\u{1}const_iterator"]
    pub fn dbm_fed_t_const_iterator_const_iterator(
        this: *mut dbm_fed_t_const_iterator,
        fed: *const dbm_fdbm_t,
    );
}
extern "C" {
    #[link_name = "\u{1}const_iterator"]
    pub fn dbm_fed_t_const_iterator_const_iterator1(
        this: *mut dbm_fed_t_const_iterator,
        fed: *const dbm_fed_t,
    );
}
extern "C" {
    #[link_name = "\u{1}const_iterator"]
    pub fn dbm_fed_t_const_iterator_const_iterator2(this: *mut dbm_fed_t_const_iterator);
}
impl dbm_fed_t_const_iterator {
    #[inline]
    pub unsafe fn null(&self) -> bool {
        dbm_fed_t_const_iterator_null(self)
    }
    #[inline]
    pub unsafe fn hasNext(&self) -> bool {
        dbm_fed_t_const_iterator_hasNext(self)
    }
    #[inline]
    pub unsafe fn new(fed: *const dbm_fdbm_t) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        dbm_fed_t_const_iterator_const_iterator(__bindgen_tmp.as_mut_ptr(), fed);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(fed: *const dbm_fed_t) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        dbm_fed_t_const_iterator_const_iterator1(__bindgen_tmp.as_mut_ptr(), fed);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        dbm_fed_t_const_iterator_const_iterator2(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[test]
fn bindgen_test_layout_dbm_fed_t() {
    assert_eq!(
        ::std::mem::size_of::<dbm_fed_t>(),
        8usize,
        concat!("Size of: ", stringify!(dbm_fed_t))
    );
    assert_eq!(
        ::std::mem::align_of::<dbm_fed_t>(),
        8usize,
        concat!("Alignment of ", stringify!(dbm_fed_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dbm_fed_t>())).ifedPtr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dbm_fed_t),
            "::",
            stringify!(ifedPtr)
        )
    );
}
extern "C" {
    #[doc = " @return the number of DBMs in this federation."]
    #[link_name = "\u{1}size"]
    pub fn dbm_fed_t_size(this: *const dbm_fed_t) -> size_t;
}
extern "C" {
    #[doc = " @return the dimension of this federation."]
    #[link_name = "\u{1}getDimension"]
    pub fn dbm_fed_t_getDimension(this: *const dbm_fed_t) -> cindex_t;
}
extern "C" {
    #[doc = " Change the dimension of this federation."]
    #[doc = " The resulting federation is empty. @post isEmpty()"]
    #[link_name = "\u{1}setDimension"]
    pub fn dbm_fed_t_setDimension(this: *mut dbm_fed_t, dim: cindex_t);
}
extern "C" {
    #[doc = " @return true if it is empty."]
    #[link_name = "\u{1}isEmpty"]
    pub fn dbm_fed_t_isEmpty(this: *const dbm_fed_t) -> bool;
}
extern "C" {
    #[doc = " Empty this federation."]
    #[link_name = "\u{1}setEmpty"]
    pub fn dbm_fed_t_setEmpty(this: *mut dbm_fed_t);
}
extern "C" {
    #[doc = " Short for setDimension(1), has the effect of deallocating the DBMs."]
    #[link_name = "\u{1}nil"]
    pub fn dbm_fed_t_nil(this: *mut dbm_fed_t);
}
extern "C" {
    #[doc = " @return true if this DBM contains the zero point."]
    #[link_name = "\u{1}hasZero"]
    pub fn dbm_fed_t_hasZero(this: *const dbm_fed_t) -> bool;
}
extern "C" {
    #[doc = " @return string representation of the"]
    #[doc = " constraints of this federation. A clock"]
    #[doc = " is always positive, so \"true\" simply means"]
    #[doc = " all clocks positive."]
    #[link_name = "\u{1}toString"]
    pub fn dbm_fed_t_toString(this: *const dbm_fed_t, arg1: *const dbm_ClockAccessor)
        -> std_string;
}
extern "C" {
    #[doc = " Computes the biggest lower cost in the zone."]
    #[doc = "  This corresponds to the value"]
    #[doc = "  \\f$\\sup\\{ c \\mid \\exists v \\in Z : c ="]
    #[doc = "  \\inf \\{ c' \\mid v[cost\\mapsto c'] \\in Z \\} \\}\\f$"]
    #[link_name = "\u{1}getUpperMinimumCost"]
    pub fn dbm_fed_t_getUpperMinimumCost(
        this: *const dbm_fed_t,
        cost: ::std::os::raw::c_int,
    ) -> i32;
}
extern "C" {
    #[doc = " Only for compatibility with priced federations."]
    #[link_name = "\u{1}getInfimum"]
    pub fn dbm_fed_t_getInfimum(this: *const dbm_fed_t) -> i32;
}
extern "C" {
    #[doc = " Compute the intersection with the axis on clock and returns the upper bound."]
    #[doc = " Returns 0 if empty intersection."]
    #[link_name = "\u{1}maxOnZero"]
    pub fn dbm_fed_t_maxOnZero(this: *mut dbm_fed_t, clock: cindex_t) -> i32;
}
extern "C" {
    #[doc = " @return a hash value that does not depend on the order of the DBMs"]
    #[doc = " but call reduce before to get a reliable value."]
    #[link_name = "\u{1}hash"]
    pub fn dbm_fed_t_hash(this: *const dbm_fed_t, seed: u32) -> u32;
}
extern "C" {
    #[doc = " @return true if arg has the same internal ifedPtr."]
    #[link_name = "\u{1}sameAs"]
    pub fn dbm_fed_t_sameAs(this: *const dbm_fed_t, arg: *const dbm_fed_t) -> bool;
}
extern "C" {
    #[doc = " Try to share the DBMs. Side-effect: affects all copies of this fed_t."]
    #[link_name = "\u{1}intern"]
    pub fn dbm_fed_t_intern(this: *mut dbm_fed_t);
}
extern "C" {
    #[doc = " Relation (wrt inclusion, approximate)."]
    #[doc = " @return this (relation) arg."]
    #[link_name = "\u{1}relation"]
    pub fn dbm_fed_t_relation(this: *const dbm_fed_t, arg: *const dbm_fed_t) -> relation_t;
}
extern "C" {
    #[link_name = "\u{1}relation"]
    pub fn dbm_fed_t_relation1(this: *const dbm_fed_t, arg: *const dbm_dbm_t) -> relation_t;
}
extern "C" {
    #[link_name = "\u{1}relation"]
    pub fn dbm_fed_t_relation2(
        this: *const dbm_fed_t,
        arg: *const raw_t,
        dim: cindex_t,
    ) -> relation_t;
}
extern "C" {
    #[doc = " Specialized relation test: >= arg (approximate)."]
    #[link_name = "\u{1}isSupersetEq"]
    pub fn dbm_fed_t_isSupersetEq(this: *const dbm_fed_t, arg: *const raw_t, dim: cindex_t)
        -> bool;
}
extern "C" {
    #[doc = " Exact (expensive) relations. See comments on dbm_t. eq: equal,"]
    #[doc = " lt: less than, gt: greater than, le: less or equal, ge: greater or equal."]
    #[doc = " @pre same dimension for eq,lt,le,gt,ge"]
    #[link_name = "\u{1}eq"]
    pub fn dbm_fed_t_eq(this: *const dbm_fed_t, arg: *const dbm_fed_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}eq"]
    pub fn dbm_fed_t_eq1(this: *const dbm_fed_t, arg: *const dbm_dbm_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}eq"]
    pub fn dbm_fed_t_eq2(this: *const dbm_fed_t, arg: *const raw_t, dim: cindex_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}lt"]
    pub fn dbm_fed_t_lt(this: *const dbm_fed_t, arg: *const dbm_fed_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}lt"]
    pub fn dbm_fed_t_lt1(this: *const dbm_fed_t, arg: *const dbm_dbm_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}lt"]
    pub fn dbm_fed_t_lt2(this: *const dbm_fed_t, arg: *const raw_t, dim: cindex_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}gt"]
    pub fn dbm_fed_t_gt(this: *const dbm_fed_t, arg: *const dbm_fed_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}gt"]
    pub fn dbm_fed_t_gt1(this: *const dbm_fed_t, arg: *const dbm_dbm_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}gt"]
    pub fn dbm_fed_t_gt2(this: *const dbm_fed_t, arg: *const raw_t, dim: cindex_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}le"]
    pub fn dbm_fed_t_le(this: *const dbm_fed_t, arg: *const dbm_fed_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}le"]
    pub fn dbm_fed_t_le1(this: *const dbm_fed_t, arg: *const dbm_dbm_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}le"]
    pub fn dbm_fed_t_le2(this: *const dbm_fed_t, arg: *const raw_t, dim: cindex_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}ge"]
    pub fn dbm_fed_t_ge(this: *const dbm_fed_t, arg: *const dbm_fed_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}ge"]
    pub fn dbm_fed_t_ge1(this: *const dbm_fed_t, arg: *const dbm_dbm_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}ge"]
    pub fn dbm_fed_t_ge2(this: *const dbm_fed_t, arg: *const raw_t, dim: cindex_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}exactRelation"]
    pub fn dbm_fed_t_exactRelation(this: *const dbm_fed_t, arg: *const dbm_fed_t) -> relation_t;
}
extern "C" {
    #[link_name = "\u{1}exactRelation"]
    pub fn dbm_fed_t_exactRelation1(this: *const dbm_fed_t, arg: *const dbm_dbm_t) -> relation_t;
}
extern "C" {
    #[link_name = "\u{1}exactRelation"]
    pub fn dbm_fed_t_exactRelation2(
        this: *const dbm_fed_t,
        arg: *const raw_t,
        dim: cindex_t,
    ) -> relation_t;
}
extern "C" {
    #[doc = " Set this federation to zero (origin)."]
    #[doc = " @post size() == 1 if dim > 1, 0 otherwise."]
    #[link_name = "\u{1}setZero"]
    pub fn dbm_fed_t_setZero(this: *mut dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " (re-)initialize the federation with no constraint."]
    #[doc = " @post size() == 1 if dim > 1, 0 otherwise."]
    #[link_name = "\u{1}setInit"]
    pub fn dbm_fed_t_setInit(this: *mut dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " Convex union of its DBMs."]
    #[link_name = "\u{1}convexHull"]
    pub fn dbm_fed_t_convexHull(this: *mut dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " Similar to dbm_t::makeUnbounded but only w.r.t. the future"]
    #[doc = " of this DBM, i.e., take max(c[i],max all lower bounds[i])"]
    #[doc = " as lower bounds (and keep strictness)."]
    #[link_name = "\u{1}makeUnboundedFrom"]
    pub fn dbm_fed_t_makeUnboundedFrom(this: *const dbm_fed_t, c: *const i32) -> dbm_dbm_t;
}
extern "C" {
    #[doc = " Widen with respect to a small drift. This is to implement"]
    #[doc = " drift w.r.t. Mani's semantics. The operation consists of"]
    #[doc = " - widening the closed contraints by 1 and make them open,"]
    #[doc = " - make all lower bounds strict,"]
    #[doc = " - return a union with the original federation."]
    #[doc = " @pre up() was called before, namely this makes sense only"]
    #[doc = " after delay and it is correct w.r.t. the algorithm only"]
    #[doc = " if the upper bounds are removed."]
    #[link_name = "\u{1}driftWiden"]
    pub fn dbm_fed_t_driftWiden(this: *mut dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " Union of 2 fed_t. @post arg.isEmpty()"]
    #[link_name = "\u{1}unionWith"]
    pub fn dbm_fed_t_unionWith(this: *mut dbm_fed_t, arg: *mut dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[link_name = "\u{1}unionWithC"]
    pub fn dbm_fed_t_unionWithC(this: *mut dbm_fed_t, arg: dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " Simply add (list concatenation) DBMs to this federation."]
    #[doc = " @pre same dimension."]
    #[link_name = "\u{1}add"]
    pub fn dbm_fed_t_add(this: *mut dbm_fed_t, arg: *const dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[link_name = "\u{1}add"]
    pub fn dbm_fed_t_add1(this: *mut dbm_fed_t, arg: *const dbm_dbm_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[link_name = "\u{1}add"]
    pub fn dbm_fed_t_add2(this: *mut dbm_fed_t, arg: *const raw_t, dim: cindex_t)
        -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " Append arg to 'this', @post arg.isEmpty()"]
    #[link_name = "\u{1}append"]
    pub fn dbm_fed_t_append(this: *mut dbm_fed_t, arg: *mut dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[link_name = "\u{1}appendC"]
    pub fn dbm_fed_t_appendC(this: *mut dbm_fed_t, arg: dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[link_name = "\u{1}append"]
    pub fn dbm_fed_t_append1(this: *mut dbm_fed_t, arg: *mut dbm_fdbm_t);
}
extern "C" {
    #[doc = " Like append but guarantee where the argument is"]
    #[doc = " inserted (beginning or end)."]
    #[link_name = "\u{1}appendBegin"]
    pub fn dbm_fed_t_appendBegin(this: *mut dbm_fed_t, arg: *mut dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[link_name = "\u{1}appendEnd"]
    pub fn dbm_fed_t_appendEnd(this: *mut dbm_fed_t, arg: *mut dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " Combination of appendEnd + incremental mergeReduce."]
    #[link_name = "\u{1}steal"]
    pub fn dbm_fed_t_steal(this: *mut dbm_fed_t, arg: *mut dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[link_name = "\u{1}stealC"]
    pub fn dbm_fed_t_stealC(this: *mut dbm_fed_t, arg: dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " Swap this federation with another."]
    #[link_name = "\u{1}swap"]
    pub fn dbm_fed_t_swap(this: *mut dbm_fed_t, arg1: *mut dbm_fed_t);
}
extern "C" {
    #[doc = " Compute (*this -= arg).down(). The interest of this"]
    #[doc = " call is that some subtractions can be avoided if the"]
    #[doc = " following down() negates their effects."]
    #[link_name = "\u{1}subtractDown"]
    pub fn dbm_fed_t_subtractDown(this: *mut dbm_fed_t, arg1: *const dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[link_name = "\u{1}subtractDown"]
    pub fn dbm_fed_t_subtractDown1(this: *mut dbm_fed_t, arg1: *const dbm_dbm_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[link_name = "\u{1}subtractDown"]
    pub fn dbm_fed_t_subtractDown2(this: *mut dbm_fed_t, arg1: *const raw_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " Methods for constraining: with one or more constraints."]
    #[doc = " Variants with @param table: indirection table for the indices."]
    #[doc = " @pre compatible indices, i != j for the constraints, and"]
    #[doc = " table is an cindex_t[getDimension()]. @see dbm_t."]
    #[link_name = "\u{1}constrain"]
    pub fn dbm_fed_t_constrain(this: *mut dbm_fed_t, i: cindex_t, value: i32) -> bool;
}
extern "C" {
    #[link_name = "\u{1}constrain"]
    pub fn dbm_fed_t_constrain1(this: *mut dbm_fed_t, i: cindex_t, j: cindex_t, c: raw_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}constrain"]
    pub fn dbm_fed_t_constrain2(
        this: *mut dbm_fed_t,
        i: cindex_t,
        j: cindex_t,
        b: i32,
        s: strictness_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}constrain"]
    pub fn dbm_fed_t_constrain3(
        this: *mut dbm_fed_t,
        i: cindex_t,
        j: cindex_t,
        b: i32,
        isStrict: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}constrain"]
    pub fn dbm_fed_t_constrain4(this: *mut dbm_fed_t, c: *const constraint_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}constrain"]
    pub fn dbm_fed_t_constrain5(this: *mut dbm_fed_t, c: *const constraint_t, n: size_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}constrain"]
    pub fn dbm_fed_t_constrain6(
        this: *mut dbm_fed_t,
        table: *const cindex_t,
        c: *const constraint_t,
        n: size_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}constrain"]
    pub fn dbm_fed_t_constrain7(
        this: *mut dbm_fed_t,
        table: *const cindex_t,
        arg1: *const base_pointer_t<constraint_t>,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}constrain"]
    pub fn dbm_fed_t_constrain8(
        this: *mut dbm_fed_t,
        table: *const cindex_t,
        arg1: *const [u64; 3usize],
    ) -> bool;
}
extern "C" {
    #[doc = " @return false if there is no intersection with the argument"]
    #[doc = " or true if there *may* be an intersection."]
    #[doc = " @pre same dimensions."]
    #[link_name = "\u{1}intersects"]
    pub fn dbm_fed_t_intersects(this: *const dbm_fed_t, arg1: *const dbm_fed_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}intersects"]
    pub fn dbm_fed_t_intersects1(this: *const dbm_fed_t, arg1: *const dbm_dbm_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}intersects"]
    pub fn dbm_fed_t_intersects2(this: *const dbm_fed_t, arg1: *const raw_t, dim: cindex_t)
        -> bool;
}
extern "C" {
    #[doc = " Delay (strongest post-condition) for all the DBMs."]
    #[link_name = "\u{1}up"]
    pub fn dbm_fed_t_up(this: *mut dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " Delay, except for stopped clocks."]
    #[doc = " @param stopped is a bit array marking which clocks are stopped."]
    #[doc = " @pre if stopped != NULL then it is a uint32_t[bits2intsize(getDimension())]."]
    #[link_name = "\u{1}upStop"]
    pub fn dbm_fed_t_upStop(this: *mut dbm_fed_t, stopped: *const u32) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " Inverse delay (weakest pre-condition) for all the DBMs."]
    #[link_name = "\u{1}down"]
    pub fn dbm_fed_t_down(this: *mut dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " Similar to upStop but for inverse delay."]
    #[link_name = "\u{1}downStop"]
    pub fn dbm_fed_t_downStop(this: *mut dbm_fed_t, stopped: *const u32) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " Free clock (unconstraint) for all the DBMs."]
    #[link_name = "\u{1}freeClock"]
    pub fn dbm_fed_t_freeClock(this: *mut dbm_fed_t, clock: cindex_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " Free upper or lower bounds only for a particular clock or"]
    #[doc = " for all clocks. @pre 0 < clock < getDimension()"]
    #[doc = " @return this. @see dbm.h"]
    #[link_name = "\u{1}freeUp"]
    pub fn dbm_fed_t_freeUp(this: *mut dbm_fed_t, clock: cindex_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[link_name = "\u{1}freeDown"]
    pub fn dbm_fed_t_freeDown(this: *mut dbm_fed_t, clock: cindex_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[link_name = "\u{1}freeAllUp"]
    pub fn dbm_fed_t_freeAllUp(this: *mut dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[link_name = "\u{1}freeAllDown"]
    pub fn dbm_fed_t_freeAllDown(this: *mut dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " Update methods where x & y are clocks, v an integer value."]
    #[doc = " x := v     -> updateValue"]
    #[doc = " x := y     -> updateClock"]
    #[doc = " x := x + v -> updateIncrement"]
    #[doc = " x := y + v -> update"]
    #[doc = " @pre 0 < x and y < getDimension(), v < infinity, and v is"]
    #[doc = " s.t. the clocks stay positive."]
    #[link_name = "\u{1}updateValue"]
    pub fn dbm_fed_t_updateValue(this: *mut dbm_fed_t, x: cindex_t, v: i32);
}
extern "C" {
    #[link_name = "\u{1}updateClock"]
    pub fn dbm_fed_t_updateClock(this: *mut dbm_fed_t, x: cindex_t, y: cindex_t);
}
extern "C" {
    #[link_name = "\u{1}updateIncrement"]
    pub fn dbm_fed_t_updateIncrement(this: *mut dbm_fed_t, x: cindex_t, v: i32);
}
extern "C" {
    #[link_name = "\u{1}update"]
    pub fn dbm_fed_t_update(this: *mut dbm_fed_t, x: cindex_t, y: cindex_t, v: i32);
}
extern "C" {
    #[doc = " @return true if this federation satisfies a constraint c_ij."]
    #[doc = " @pre i != j, i and j < getDimension()"]
    #[link_name = "\u{1}satisfies"]
    pub fn dbm_fed_t_satisfies(this: *const dbm_fed_t, i: cindex_t, j: cindex_t, c: raw_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}satisfies"]
    pub fn dbm_fed_t_satisfies1(this: *const dbm_fed_t, c: *const constraint_t) -> bool;
}
extern "C" {
    #[doc = " @return true if this federation has points that can delay infinitely."]
    #[link_name = "\u{1}isUnbounded"]
    pub fn dbm_fed_t_isUnbounded(this: *const dbm_fed_t) -> bool;
}
extern "C" {
    #[doc = " @return the part of the federation that is unbounded (maybe empty)."]
    #[link_name = "\u{1}getUnbounded"]
    pub fn dbm_fed_t_getUnbounded(this: *const dbm_fed_t) -> dbm_fed_t;
}
extern "C" {
    #[doc = " @return the part of the federation that is bounded (maybe empty)."]
    #[link_name = "\u{1}getBounded"]
    pub fn dbm_fed_t_getBounded(this: *const dbm_fed_t) -> dbm_fed_t;
}
extern "C" {
    #[doc = " Make upper or lower finite bounds non strict for all the DBMs."]
    #[doc = " @see dbm.h."]
    #[doc = " @return this."]
    #[link_name = "\u{1}relaxUp"]
    pub fn dbm_fed_t_relaxUp(this: *mut dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[link_name = "\u{1}relaxDown"]
    pub fn dbm_fed_t_relaxDown(this: *mut dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " Make lower bounds strict."]
    #[doc = " @return this."]
    #[link_name = "\u{1}tightenDown"]
    pub fn dbm_fed_t_tightenDown(this: *mut dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " Make upper bounds strict."]
    #[doc = " @return this."]
    #[link_name = "\u{1}tightenUp"]
    pub fn dbm_fed_t_tightenUp(this: *mut dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " Similar for all bounds of a particular clock for all the DBMs."]
    #[doc = " @see dbm.h. Special for clock == 0:"]
    #[doc = " relaxUp(0) = relaxDown() and relaxDown(0) = relaxUp()."]
    #[link_name = "\u{1}relaxUpClock"]
    pub fn dbm_fed_t_relaxUpClock(this: *mut dbm_fed_t, clock: cindex_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[link_name = "\u{1}relaxDownClock"]
    pub fn dbm_fed_t_relaxDownClock(this: *mut dbm_fed_t, clock: cindex_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " Make all constraints (except infinity) non strict for all the DBMs."]
    #[link_name = "\u{1}relaxAll"]
    pub fn dbm_fed_t_relaxAll(this: *mut dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " Remove redundant DBMs (if included in ONE other DBM)."]
    #[doc = " @post side effect: all copies of this fed_t are affected so"]
    #[doc = " do not mix iterators and reduce()."]
    #[doc = " @return this."]
    #[link_name = "\u{1}reduce"]
    pub fn dbm_fed_t_reduce(this: *mut dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " This method is useful only for experiments."]
    #[link_name = "\u{1}noReduce"]
    pub fn dbm_fed_t_noReduce(this: *mut dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " Remove redundant DBMs (if included in the UNION of the other DBMs)."]
    #[doc = " @post same side effect as reduce()."]
    #[doc = " @return this."]
    #[link_name = "\u{1}expensiveReduce"]
    pub fn dbm_fed_t_expensiveReduce(this: *mut dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " Try to merge DBMs by pairs."]
    #[doc = " @post same side effect as reduce()."]
    #[doc = " @param skip is the number of DBMs to skip for the"]
    #[doc = " reduction, useful for incremental reductions."]
    #[doc = " @param level is how expensive it can be: 0=default,"]
    #[doc = " 1=more expensive (more effective), 2=much more expensive"]
    #[doc = " (hopefully even more effective)."]
    #[doc = " @return this."]
    #[link_name = "\u{1}mergeReduce"]
    pub fn dbm_fed_t_mergeReduce(
        this: *mut dbm_fed_t,
        skip: size_t,
        level: ::std::os::raw::c_int,
    ) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " The mergeReduce implementation uses a heuristic"]
    #[doc = " to avoid computing (possibly) useless subtractions."]
    #[doc = " It is activated by default but it may miss reductions."]
    #[doc = " If you want to spend more time but get a better result"]
    #[doc = " set it to false."]
    #[link_name = "\u{1}heuristicMergeReduce"]
    pub fn dbm_fed_t_heuristicMergeReduce(active: bool);
}
extern "C" {
    #[doc = " Use a heuristic to recompute parts of the federation as"]
    #[doc = " part=convexHull(part)-(convexHull(part)-part)"]
    #[doc = " @return this."]
    #[link_name = "\u{1}convexReduce"]
    pub fn dbm_fed_t_convexReduce(this: *mut dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " Try to replace this by convexHull(this)-(convexHull(this)-this)"]
    #[doc = " @return this."]
    #[link_name = "\u{1}expensiveConvexReduce"]
    pub fn dbm_fed_t_expensiveConvexReduce(this: *mut dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " Find partitions in the federation and reduce them separately."]
    #[doc = " @return this."]
    #[link_name = "\u{1}partitionReduce"]
    pub fn dbm_fed_t_partitionReduce(this: *mut dbm_fed_t) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " @return true if a point (discrete or \"real\") is included"]
    #[doc = " in this federation (ie in one of its DBMs)."]
    #[doc = " @pre same dimension."]
    #[link_name = "\u{1}contains"]
    pub fn dbm_fed_t_contains(this: *const dbm_fed_t, point: *const dbm_IntValuation) -> bool;
}
extern "C" {
    #[link_name = "\u{1}contains"]
    pub fn dbm_fed_t_contains1(this: *const dbm_fed_t, point: *const i32, dim: cindex_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}contains"]
    pub fn dbm_fed_t_contains2(this: *const dbm_fed_t, point: *const dbm_DoubleValuation) -> bool;
}
extern "C" {
    #[link_name = "\u{1}contains"]
    pub fn dbm_fed_t_contains3(this: *const dbm_fed_t, point: *const f64, dim: cindex_t) -> bool;
}
extern "C" {
    #[doc = " @return the 'almost max' possible delay backward from"]
    #[doc = " a point while still staying inside the federation. It"]
    #[doc = " is 'almost max' since we want a discrete value, which"]
    #[doc = " cannot me the max when we have strict constraints."]
    #[doc = " The precision is 0.5. 0.0 may be returned if the point"]
    #[doc = " is too close to a border."]
    #[doc = " @param point: the point to go backward from."]
    #[doc = " @pre dim = getDimension() && contains(point)"]
    #[link_name = "\u{1}possibleBackDelay"]
    pub fn dbm_fed_t_possibleBackDelay(
        this: *const dbm_fed_t,
        point: *const dbm_DoubleValuation,
    ) -> f64;
}
extern "C" {
    #[link_name = "\u{1}possibleBackDelay"]
    pub fn dbm_fed_t_possibleBackDelay1(
        this: *const dbm_fed_t,
        point: *const f64,
        dim: cindex_t,
    ) -> f64;
}
extern "C" {
    #[doc = " Compute the 'almost min' necessary delay from"]
    #[doc = " a point to enter this federation. If this point"]
    #[doc = " is already contained in this federation, 0.0 is"]
    #[doc = " returned. The result is 'almost min' since we"]
    #[doc = " want a discrete value, which is not possible in"]
    #[doc = " case of strict constraints."]
    #[doc = " @pre dim == getDimension() and point[0] == 0.0"]
    #[doc = " otherwise the computation will not work."]
    #[doc = " @return true if it is possible to reach this federation"]
    #[doc = " by delaying, or false if this federation is empty or it"]
    #[doc = " is not possible to reach it by delaying."]
    #[doc = " The delay is written in t."]
    #[doc = " @param minVal,minStrict: another (optional) output"]
    #[doc = " is provided in the form of a delay value and a"]
    #[doc = " flag telling if the delay is strict, e.g.,"]
    #[doc = " wait >= 2.1 or wait > 2.1."]
    #[doc = " @pre minVal and minStrict are both NULL or non NULL."]
    #[link_name = "\u{1}getMinDelay"]
    pub fn dbm_fed_t_getMinDelay(
        this: *const dbm_fed_t,
        point: *const dbm_DoubleValuation,
        t: *mut f64,
        minVal: *mut f64,
        minStrict: *mut bool,
        stopped: *const u32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}getMinDelay"]
    pub fn dbm_fed_t_getMinDelay1(
        this: *const dbm_fed_t,
        point: *const f64,
        dim: cindex_t,
        t: *mut f64,
        minVal: *mut f64,
        minStrict: *mut bool,
        stopped: *const u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Similarly for the past."]
    #[doc = "  The returned value (in t) is <= max, where max."]
    #[doc = "  @pre max > 0 otherwise this is meaningless."]
    #[link_name = "\u{1}getMaxBackDelay"]
    pub fn dbm_fed_t_getMaxBackDelay(
        this: *const dbm_fed_t,
        point: *const dbm_DoubleValuation,
        t: *mut f64,
        max: f64,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}getMaxBackDelay"]
    pub fn dbm_fed_t_getMaxBackDelay1(
        this: *const dbm_fed_t,
        point: *const f64,
        dim: cindex_t,
        t: *mut f64,
        max: f64,
    ) -> bool;
}
extern "C" {
    #[doc = " Compute the approximate interval delay from"]
    #[doc = " a point to enter this federation and to stay"]
    #[doc = " inside continuously."]
    #[doc = " @return true if it is possible to reach this federation"]
    #[doc = " by delaying, false otherwise."]
    #[doc = " @param min and max give the interval, max can be"]
    #[doc = " HUGE_VAL to mean infinity."]
    #[link_name = "\u{1}getDelay"]
    pub fn dbm_fed_t_getDelay(
        this: *const dbm_fed_t,
        point: *const dbm_DoubleValuation,
        min: *mut f64,
        max: *mut f64,
        minVal: *mut f64,
        minStrict: *mut bool,
        maxVal: *mut f64,
        maxStrict: *mut bool,
        stopped: *const u32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}getDelay"]
    pub fn dbm_fed_t_getDelay1(
        this: *const dbm_fed_t,
        point: *const f64,
        dim: cindex_t,
        min: *mut f64,
        max: *mut f64,
        minVal: *mut f64,
        minStrict: *mut bool,
        maxVal: *mut f64,
        maxStrict: *mut bool,
        stopped: *const u32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}isConstrainedBy"]
    pub fn dbm_fed_t_isConstrainedBy(
        this: *const dbm_fed_t,
        arg1: cindex_t,
        arg2: cindex_t,
        arg3: raw_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Extrapolations: @see dbm_##method functions in dbm.h."]
    #[doc = " @pre max, lower, and upper are int32_t[getDimension()]"]
    #[link_name = "\u{1}extrapolateMaxBounds"]
    pub fn dbm_fed_t_extrapolateMaxBounds(this: *mut dbm_fed_t, max: *const i32);
}
extern "C" {
    #[link_name = "\u{1}diagonalExtrapolateMaxBounds"]
    pub fn dbm_fed_t_diagonalExtrapolateMaxBounds(this: *mut dbm_fed_t, max: *const i32);
}
extern "C" {
    #[link_name = "\u{1}extrapolateLUBounds"]
    pub fn dbm_fed_t_extrapolateLUBounds(
        this: *mut dbm_fed_t,
        lower: *const i32,
        upper: *const i32,
    );
}
extern "C" {
    #[link_name = "\u{1}diagonalExtrapolateLUBounds"]
    pub fn dbm_fed_t_diagonalExtrapolateLUBounds(
        this: *mut dbm_fed_t,
        lower: *const i32,
        upper: *const i32,
    );
}
extern "C" {
    #[doc = " \"Split-extrapolation\". Split the DBMs with the diagonal"]
    #[doc = " constraints given in argument, apply extrapolateMaxBounds"]
    #[doc = " on the result, and make sure that the resulting DBMs are"]
    #[doc = " still constrained by these diagonals."]
    #[doc = " @param begin .. end give the diagonal constraints for"]
    #[doc = " splitting (from begin (inclusive) to end (exclusive))."]
    #[doc = " @param max is the array of maximal bounds."]
    #[link_name = "\u{1}splitExtrapolate"]
    pub fn dbm_fed_t_splitExtrapolate(
        this: *mut dbm_fed_t,
        begin: *const constraint_t,
        end: *const constraint_t,
        max: *const i32,
    );
}
extern "C" {
    #[doc = " Resize all the DBMs of this federation, @see dbm_t."]
    #[doc = " @see dbm_shrinkExpand in dbm.h."]
    #[doc = " @param bitSrc,bitDst,bitSize: bit strings of (int) size bitSize"]
    #[doc = " that mark the source and destination active clocks."]
    #[doc = " @param table: redirection table to write."]
    #[doc = " @pre bitSrc & bitDst are uint32_t[bitSize] and"]
    #[doc = " table is a uint32_t[32*bitSize]"]
    #[doc = " @post the indirection table is written."]
    #[link_name = "\u{1}resize"]
    pub fn dbm_fed_t_resize(
        this: *mut dbm_fed_t,
        bitSrc: *const u32,
        bitDst: *const u32,
        bitSize: size_t,
        table: *mut cindex_t,
    );
}
extern "C" {
    #[doc = " Resize and change clocks of all the DBMs of this federation."]
    #[doc = " The updated DBMs will have its clocks i coming from target[i]"]
    #[doc = " in the original DBM."]
    #[doc = " @param target is the table that says where to put the current"]
    #[doc = " clocks in the target DBMs. If target[i] = ~0 then a new free"]
    #[doc = " clock is inserted."]
    #[doc = " @pre newDim > 0, target is a cindex_t[newDim], and"]
    #[doc = " for all i < newDim, target[i] < getDimension()."]
    #[link_name = "\u{1}changeClocks"]
    pub fn dbm_fed_t_changeClocks(this: *mut dbm_fed_t, target: *const cindex_t, newDim: cindex_t);
}
extern "C" {
    #[doc = " Swap clocks x and y."]
    #[link_name = "\u{1}swapClocks"]
    pub fn dbm_fed_t_swapClocks(this: *mut dbm_fed_t, x: cindex_t, y: cindex_t);
}
extern "C" {
    #[doc = " Get a clock valuation and change only the clocks"]
    #[doc = " that are marked free. The point will belong to one"]
    #[doc = " DBM of this federation, it is unspecified which one."]
    #[doc = " @param cval: clock valuation to write."]
    #[doc = " @param freeC: free clocks to write, if freeC == NULL, then"]
    #[doc = " all clocks are considered free."]
    #[doc = " @return cval"]
    #[doc = " @throw std::out_of_range if the generation fails"]
    #[doc = " if isEmpty() or cval too constrained."]
    #[doc = " @post if freeC != NULL, forall i < dim: freeC[i] = false"]
    #[doc = " @pre same dimension."]
    #[link_name = "\u{1}getValuation"]
    pub fn dbm_fed_t_getValuation(
        this: *const dbm_fed_t,
        cval: *mut dbm_DoubleValuation,
        freeC: *mut bool,
    ) -> *mut dbm_DoubleValuation;
}
extern "C" {
    #[doc = " predt operation: temporal predecessor of this federation"]
    #[doc = " avoiding 'bad'. The extra argument 'restrict' is to apply"]
    #[doc = " intersection (thus restricting) to the result, which *may*"]
    #[doc = " improve the algorithm. The argument is optional and its"]
    #[doc = " dimension must match getDimension()."]
    #[doc = " @post the points in the resulting federation may delay"]
    #[doc = " (and stay in the result) until they belong to this federation"]
    #[doc = " without entering bad."]
    #[doc = " @pre same dimension."]
    #[link_name = "\u{1}predt"]
    pub fn dbm_fed_t_predt(
        this: *mut dbm_fed_t,
        bad: *const dbm_fed_t,
        restrict: *const raw_t,
    ) -> *mut dbm_fed_t;
}
extern "C" {
    #[link_name = "\u{1}predt"]
    pub fn dbm_fed_t_predt1(
        this: *mut dbm_fed_t,
        bad: *const dbm_dbm_t,
        restrict: *const raw_t,
    ) -> *mut dbm_fed_t;
}
extern "C" {
    #[link_name = "\u{1}predt"]
    pub fn dbm_fed_t_predt2(
        this: *mut dbm_fed_t,
        bad: *const raw_t,
        dim: cindex_t,
        restrict: *const raw_t,
    ) -> *mut dbm_fed_t;
}
extern "C" {
    #[doc = " @return true if this fed_t is included in predt(good,bad)"]
    #[doc = " This test may terminate earlier than calling le(predt(good,bad))"]
    #[doc = " because predt does not have to be computed in full sometimes."]
    #[link_name = "\u{1}isIncludedInPredt"]
    pub fn dbm_fed_t_isIncludedInPredt(
        this: *const dbm_fed_t,
        good: *const dbm_fed_t,
        bad: *const dbm_fed_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Identify test to know if this federation has a specific DBM."]
    #[doc = " If (dbm_t) arg is empty, then it is trivially true (if same dimension)."]
    #[link_name = "\u{1}has"]
    pub fn dbm_fed_t_has(this: *const dbm_fed_t, arg: *const dbm_dbm_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}has"]
    pub fn dbm_fed_t_has1(this: *const dbm_fed_t, arg: *const raw_t, dim: cindex_t) -> bool;
}
extern "C" {
    #[doc = " Similar but test with exact same dbm_t. Note: an empty federation"]
    #[doc = " is an empty list and an empty DBM is an empty zone. Both are"]
    #[doc = " compatible since they contain no point but empty_fed.hasSame(empty_dbm)"]
    #[doc = " will return false even if the dimensions are the same since an empty"]
    #[doc = " fed_t contains no dbm_t at all."]
    #[link_name = "\u{1}hasSame"]
    pub fn dbm_fed_t_hasSame(this: *const dbm_fed_t, arg: *const dbm_dbm_t) -> bool;
}
extern "C" {
    #[doc = " Remove the DBMs that are included in DBMs of arg (pair-wise"]
    #[doc = " inclusion checking). WARNING: If sameAs(arg) then you will"]
    #[doc = " empty this federation *and* the argument."]
    #[doc = " @pre same dimension."]
    #[doc = " @return !(arg <= *this) if arg is a dbm_t."]
    #[link_name = "\u{1}removeIncludedIn"]
    pub fn dbm_fed_t_removeIncludedIn(this: *mut dbm_fed_t, arg: *const dbm_fed_t);
}
extern "C" {
    #[link_name = "\u{1}removeIncludedIn"]
    pub fn dbm_fed_t_removeIncludedIn1(this: *mut dbm_fed_t, arg: *const dbm_dbm_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}removeIncludedIn"]
    pub fn dbm_fed_t_removeIncludedIn2(
        this: *mut dbm_fed_t,
        arg: *const raw_t,
        dim: cindex_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @return (this-arg).isEmpty() but it is able to"]
    #[doc = " stop the subtraction early if it is not empty and"]
    #[doc = " it does not modify itself."]
    #[doc = " @pre dbm_isValid(arg, dim) and dim == getDimension()"]
    #[link_name = "\u{1}isSubtractionEmpty"]
    pub fn dbm_fed_t_isSubtractionEmpty(
        this: *const dbm_fed_t,
        arg: *const raw_t,
        dim: cindex_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}isSubtractionEmpty"]
    pub fn dbm_fed_t_isSubtractionEmpty1(this: *const dbm_fed_t, arg: *const dbm_dbm_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}isSubtractionEmpty"]
    pub fn dbm_fed_t_isSubtractionEmpty2(this: *const dbm_fed_t, arg: *const dbm_fed_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}isSubtractionEmpty"]
    pub fn dbm_fed_t_isSubtractionEmpty3(
        dbm: *const raw_t,
        dim: cindex_t,
        fed: *const dbm_fed_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Subtract DBM arg1 - DBM arg2 wrapper functions."]
    #[link_name = "\u{1}subtract"]
    pub fn dbm_fed_t_subtract(arg1: *const raw_t, arg2: *const raw_t, dim: cindex_t) -> dbm_fed_t;
}
extern "C" {
    #[link_name = "\u{1}subtract"]
    pub fn dbm_fed_t_subtract1(arg1: *const dbm_dbm_t, arg2: *const raw_t) -> dbm_fed_t;
}
extern "C" {
    #[link_name = "\u{1}subtract"]
    pub fn dbm_fed_t_subtract2(arg1: *const dbm_dbm_t, arg2: *const dbm_dbm_t) -> dbm_fed_t;
}
extern "C" {
    #[doc = " @return a new fed_t made of all the (weak) lower bounds of the original"]
    #[doc = " fed_t (i.e. no diagonals) but without overlapping."]
    #[link_name = "\u{1}toLowerBounds"]
    pub fn dbm_fed_t_toLowerBounds(this: *const dbm_fed_t) -> dbm_fed_t;
}
extern "C" {
    #[doc = " Similar but for upper bounds."]
    #[link_name = "\u{1}toUpperBounds"]
    pub fn dbm_fed_t_toUpperBounds(this: *const dbm_fed_t) -> dbm_fed_t;
}
extern "C" {
    #[doc = " @return the max upper bound (raw) of a clock."]
    #[link_name = "\u{1}getMaxUpper"]
    pub fn dbm_fed_t_getMaxUpper(this: *const dbm_fed_t, arg1: cindex_t) -> raw_t;
}
extern "C" {
    #[doc = " @return the max lower bound (raw) of a clock."]
    #[link_name = "\u{1}getMaxLower"]
    pub fn dbm_fed_t_getMaxLower(this: *const dbm_fed_t, arg1: cindex_t) -> raw_t;
}
extern "C" {
    #[doc = " Clean-up the federation of its empty dbm_t."]
    #[doc = " Normally this is never needed except if the mutable"]
    #[doc = " iterator is used and makes some dbm_t empty."]
    #[link_name = "\u{1}removeEmpty"]
    pub fn dbm_fed_t_removeEmpty(this: *mut dbm_fed_t);
}
extern "C" {
    #[doc = " @return true if this fed_t has an empty dbm_t in its list."]
    #[doc = " Normally this should never occur, unless you play with dbm_t"]
    #[doc = " manually with the iterator. This is used mainly for testing."]
    #[link_name = "\u{1}hasEmpty"]
    pub fn dbm_fed_t_hasEmpty(this: *const dbm_fed_t) -> bool;
}
extern "C" {
    #[doc = " Access to iterators. Limitation: you cannot modify the original"]
    #[doc = " fed_t object otherwise the iterator will be invalidated. In"]
    #[doc = " addition, you cannot copy the original either if the non const"]
    #[doc = " iterator is used."]
    #[link_name = "\u{1}begin"]
    pub fn dbm_fed_t_begin(this: *const dbm_fed_t) -> dbm_fed_t_const_iterator;
}
extern "C" {
    #[link_name = "\u{1}end"]
    pub fn dbm_fed_t_end(this: *const dbm_fed_t) -> dbm_fed_t_const_iterator;
}
extern "C" {
    #[link_name = "\u{1}beginMutable"]
    pub fn dbm_fed_t_beginMutable(this: *mut dbm_fed_t) -> dbm_fed_t_iterator;
}
extern "C" {
    #[link_name = "\u{1}endMutable"]
    pub fn dbm_fed_t_endMutable(this: *const dbm_fed_t) -> dbm_fed_t_iterator;
}
extern "C" {
    #[link_name = "\u{1}erase"]
    pub fn dbm_fed_t_erase(
        this: *mut dbm_fed_t,
        iter: *mut dbm_fed_t_iterator,
    ) -> dbm_fed_t_iterator;
}
extern "C" {
    #[doc = " Dump its list of ifed_t and reload them. This is"]
    #[doc = " useful for testing mainly but can be extended later"]
    #[doc = " for saving or loading a fed_t."]
    #[doc = " @param mem: a ifed_t[size()]"]
    #[doc = " @post isEmpty()"]
    #[doc = " @return size()"]
    #[link_name = "\u{1}write"]
    pub fn dbm_fed_t_write(this: *mut dbm_fed_t, mem: *mut *mut dbm_fdbm_t) -> size_t;
}
extern "C" {
    #[doc = " Symmetric: read."]
    #[doc = " @param fed,size: a ifed_t[size]"]
    #[doc = " @post the ifed list is re-linked and belongs to this fed_t."]
    #[link_name = "\u{1}read"]
    pub fn dbm_fed_t_read(this: *mut dbm_fed_t, fed: *mut *mut dbm_fdbm_t, size: size_t);
}
extern "C" {
    #[doc = " @return its first dbm_t, @pre size() > 0"]
    #[link_name = "\u{1}const_dbmt"]
    pub fn dbm_fed_t_const_dbmt(this: *const dbm_fed_t) -> *const dbm_dbm_t;
}
extern "C" {
    #[doc = " @return its dbm_t, @pre size() >= 1"]
    #[doc = " This is a dangerous access, whatever you do"]
    #[doc = " with this dbm_t *never* have it empty."]
    #[link_name = "\u{1}dbmt"]
    pub fn dbm_fed_t_dbmt(this: *mut dbm_fed_t) -> *mut dbm_dbm_t;
}
extern "C" {
    #[doc = " Remove a dbm_t from this fed_t. The match uses dbm_t::sameAs(..)"]
    #[doc = " @return true if arg was removed, false otherwise."]
    #[link_name = "\u{1}removeThisDBM"]
    pub fn dbm_fed_t_removeThisDBM(this: *mut dbm_fed_t, dbm: *const dbm_dbm_t) -> bool;
}
extern "C" {
    #[doc = " Ensure this ifed_t is mutable."]
    #[link_name = "\u{1}setMutable"]
    pub fn dbm_fed_t_setMutable(this: *mut dbm_fed_t);
}
extern "C" {
    #[doc = " @return ifedPtr with basic checks."]
    #[link_name = "\u{1}ifed"]
    pub fn dbm_fed_t_ifed(this: *mut dbm_fed_t) -> *mut dbm_ifed_t;
}
extern "C" {
    #[link_name = "\u{1}ifed"]
    pub fn dbm_fed_t_ifed1(this: *const dbm_fed_t) -> *const dbm_ifed_t;
}
extern "C" {
    #[doc = " Initialize a fed_t to empty federation of a given dimension."]
    #[doc = " @param dim: dimension of the federation."]
    #[doc = " @post isEmpty()"]
    #[link_name = "\u{1}fed_t"]
    pub fn dbm_fed_t_fed_t(this: *mut dbm_fed_t, dim: cindex_t);
}
extern "C" {
    #[doc = " Standard copy constructor."]
    #[link_name = "\u{1}fed_t"]
    pub fn dbm_fed_t_fed_t1(this: *mut dbm_fed_t, arg: *const dbm_fed_t);
}
extern "C" {
    #[doc = " Wrap a DBM in a federation."]
    #[link_name = "\u{1}fed_t"]
    pub fn dbm_fed_t_fed_t2(this: *mut dbm_fed_t, arg: *const dbm_dbm_t);
}
extern "C" {
    #[doc = " Copy a DBM matrix in a federation."]
    #[link_name = "\u{1}fed_t"]
    pub fn dbm_fed_t_fed_t3(this: *mut dbm_fed_t, arg: *const raw_t, dim: cindex_t);
}
extern "C" {
    #[doc = " Special constructor to copy the result of a pending operation."]
    #[doc = " @param op: clock operation."]
    #[link_name = "\u{1}fed_t"]
    pub fn dbm_fed_t_fed_t4(this: *mut dbm_fed_t, op: *const dbm_ClockOperation<dbm_fed_t>);
}
extern "C" {
    #[link_name = "\u{1}fed_t_destructor"]
    pub fn dbm_fed_t_fed_t_destructor(this: *mut dbm_fed_t);
}
impl dbm_fed_t {
    #[inline]
    pub unsafe fn size(&self) -> size_t {
        dbm_fed_t_size(self)
    }
    #[inline]
    pub unsafe fn getDimension(&self) -> cindex_t {
        dbm_fed_t_getDimension(self)
    }
    #[inline]
    pub unsafe fn setDimension(&mut self, dim: cindex_t) {
        dbm_fed_t_setDimension(self, dim)
    }
    #[inline]
    pub unsafe fn isEmpty(&self) -> bool {
        dbm_fed_t_isEmpty(self)
    }
    #[inline]
    pub unsafe fn setEmpty(&mut self) {
        dbm_fed_t_setEmpty(self)
    }
    #[inline]
    pub unsafe fn nil(&mut self) {
        dbm_fed_t_nil(self)
    }
    #[inline]
    pub unsafe fn hasZero(&self) -> bool {
        dbm_fed_t_hasZero(self)
    }
    #[inline]
    pub unsafe fn toString(&self, arg1: *const dbm_ClockAccessor) -> std_string {
        dbm_fed_t_toString(self, arg1)
    }
    #[inline]
    pub unsafe fn getUpperMinimumCost(&self, cost: ::std::os::raw::c_int) -> i32 {
        dbm_fed_t_getUpperMinimumCost(self, cost)
    }
    #[inline]
    pub unsafe fn getInfimum(&self) -> i32 {
        dbm_fed_t_getInfimum(self)
    }
    #[inline]
    pub unsafe fn maxOnZero(&mut self, clock: cindex_t) -> i32 {
        dbm_fed_t_maxOnZero(self, clock)
    }
    #[inline]
    pub unsafe fn hash(&self, seed: u32) -> u32 {
        dbm_fed_t_hash(self, seed)
    }
    #[inline]
    pub unsafe fn sameAs(&self, arg: *const dbm_fed_t) -> bool {
        dbm_fed_t_sameAs(self, arg)
    }
    #[inline]
    pub unsafe fn intern(&mut self) {
        dbm_fed_t_intern(self)
    }
    #[inline]
    pub unsafe fn relation(&self, arg: *const dbm_fed_t) -> relation_t {
        dbm_fed_t_relation(self, arg)
    }
    #[inline]
    pub unsafe fn relation1(&self, arg: *const dbm_dbm_t) -> relation_t {
        dbm_fed_t_relation1(self, arg)
    }
    #[inline]
    pub unsafe fn relation2(&self, arg: *const raw_t, dim: cindex_t) -> relation_t {
        dbm_fed_t_relation2(self, arg, dim)
    }
    #[inline]
    pub unsafe fn isSupersetEq(&self, arg: *const raw_t, dim: cindex_t) -> bool {
        dbm_fed_t_isSupersetEq(self, arg, dim)
    }
    #[inline]
    pub unsafe fn eq(&self, arg: *const dbm_fed_t) -> bool {
        dbm_fed_t_eq(self, arg)
    }
    #[inline]
    pub unsafe fn eq1(&self, arg: *const dbm_dbm_t) -> bool {
        dbm_fed_t_eq1(self, arg)
    }
    #[inline]
    pub unsafe fn eq2(&self, arg: *const raw_t, dim: cindex_t) -> bool {
        dbm_fed_t_eq2(self, arg, dim)
    }
    #[inline]
    pub unsafe fn lt(&self, arg: *const dbm_fed_t) -> bool {
        dbm_fed_t_lt(self, arg)
    }
    #[inline]
    pub unsafe fn lt1(&self, arg: *const dbm_dbm_t) -> bool {
        dbm_fed_t_lt1(self, arg)
    }
    #[inline]
    pub unsafe fn lt2(&self, arg: *const raw_t, dim: cindex_t) -> bool {
        dbm_fed_t_lt2(self, arg, dim)
    }
    #[inline]
    pub unsafe fn gt(&self, arg: *const dbm_fed_t) -> bool {
        dbm_fed_t_gt(self, arg)
    }
    #[inline]
    pub unsafe fn gt1(&self, arg: *const dbm_dbm_t) -> bool {
        dbm_fed_t_gt1(self, arg)
    }
    #[inline]
    pub unsafe fn gt2(&self, arg: *const raw_t, dim: cindex_t) -> bool {
        dbm_fed_t_gt2(self, arg, dim)
    }
    #[inline]
    pub unsafe fn le(&self, arg: *const dbm_fed_t) -> bool {
        dbm_fed_t_le(self, arg)
    }
    #[inline]
    pub unsafe fn le1(&self, arg: *const dbm_dbm_t) -> bool {
        dbm_fed_t_le1(self, arg)
    }
    #[inline]
    pub unsafe fn le2(&self, arg: *const raw_t, dim: cindex_t) -> bool {
        dbm_fed_t_le2(self, arg, dim)
    }
    #[inline]
    pub unsafe fn ge(&self, arg: *const dbm_fed_t) -> bool {
        dbm_fed_t_ge(self, arg)
    }
    #[inline]
    pub unsafe fn ge1(&self, arg: *const dbm_dbm_t) -> bool {
        dbm_fed_t_ge1(self, arg)
    }
    #[inline]
    pub unsafe fn ge2(&self, arg: *const raw_t, dim: cindex_t) -> bool {
        dbm_fed_t_ge2(self, arg, dim)
    }
    #[inline]
    pub unsafe fn exactRelation(&self, arg: *const dbm_fed_t) -> relation_t {
        dbm_fed_t_exactRelation(self, arg)
    }
    #[inline]
    pub unsafe fn exactRelation1(&self, arg: *const dbm_dbm_t) -> relation_t {
        dbm_fed_t_exactRelation1(self, arg)
    }
    #[inline]
    pub unsafe fn exactRelation2(&self, arg: *const raw_t, dim: cindex_t) -> relation_t {
        dbm_fed_t_exactRelation2(self, arg, dim)
    }
    #[inline]
    pub unsafe fn setZero(&mut self) -> *mut dbm_fed_t {
        dbm_fed_t_setZero(self)
    }
    #[inline]
    pub unsafe fn setInit(&mut self) -> *mut dbm_fed_t {
        dbm_fed_t_setInit(self)
    }
    #[inline]
    pub unsafe fn convexHull(&mut self) -> *mut dbm_fed_t {
        dbm_fed_t_convexHull(self)
    }
    #[inline]
    pub unsafe fn makeUnboundedFrom(&self, c: *const i32) -> dbm_dbm_t {
        dbm_fed_t_makeUnboundedFrom(self, c)
    }
    #[inline]
    pub unsafe fn driftWiden(&mut self) -> *mut dbm_fed_t {
        dbm_fed_t_driftWiden(self)
    }
    #[inline]
    pub unsafe fn unionWith(&mut self, arg: *mut dbm_fed_t) -> *mut dbm_fed_t {
        dbm_fed_t_unionWith(self, arg)
    }
    #[inline]
    pub unsafe fn unionWithC(&mut self, arg: dbm_fed_t) -> *mut dbm_fed_t {
        dbm_fed_t_unionWithC(self, arg)
    }
    #[inline]
    pub unsafe fn add(&mut self, arg: *const dbm_fed_t) -> *mut dbm_fed_t {
        dbm_fed_t_add(self, arg)
    }
    #[inline]
    pub unsafe fn add1(&mut self, arg: *const dbm_dbm_t) -> *mut dbm_fed_t {
        dbm_fed_t_add1(self, arg)
    }
    #[inline]
    pub unsafe fn add2(&mut self, arg: *const raw_t, dim: cindex_t) -> *mut dbm_fed_t {
        dbm_fed_t_add2(self, arg, dim)
    }
    #[inline]
    pub unsafe fn append(&mut self, arg: *mut dbm_fed_t) -> *mut dbm_fed_t {
        dbm_fed_t_append(self, arg)
    }
    #[inline]
    pub unsafe fn appendC(&mut self, arg: dbm_fed_t) -> *mut dbm_fed_t {
        dbm_fed_t_appendC(self, arg)
    }
    #[inline]
    pub unsafe fn append1(&mut self, arg: *mut dbm_fdbm_t) {
        dbm_fed_t_append1(self, arg)
    }
    #[inline]
    pub unsafe fn appendBegin(&mut self, arg: *mut dbm_fed_t) -> *mut dbm_fed_t {
        dbm_fed_t_appendBegin(self, arg)
    }
    #[inline]
    pub unsafe fn appendEnd(&mut self, arg: *mut dbm_fed_t) -> *mut dbm_fed_t {
        dbm_fed_t_appendEnd(self, arg)
    }
    #[inline]
    pub unsafe fn steal(&mut self, arg: *mut dbm_fed_t) -> *mut dbm_fed_t {
        dbm_fed_t_steal(self, arg)
    }
    #[inline]
    pub unsafe fn stealC(&mut self, arg: dbm_fed_t) -> *mut dbm_fed_t {
        dbm_fed_t_stealC(self, arg)
    }
    #[inline]
    pub unsafe fn swap(&mut self, arg1: *mut dbm_fed_t) {
        dbm_fed_t_swap(self, arg1)
    }
    #[inline]
    pub unsafe fn subtractDown(&mut self, arg1: *const dbm_fed_t) -> *mut dbm_fed_t {
        dbm_fed_t_subtractDown(self, arg1)
    }
    #[inline]
    pub unsafe fn subtractDown1(&mut self, arg1: *const dbm_dbm_t) -> *mut dbm_fed_t {
        dbm_fed_t_subtractDown1(self, arg1)
    }
    #[inline]
    pub unsafe fn subtractDown2(&mut self, arg1: *const raw_t) -> *mut dbm_fed_t {
        dbm_fed_t_subtractDown2(self, arg1)
    }
    #[inline]
    pub unsafe fn constrain(&mut self, i: cindex_t, value: i32) -> bool {
        dbm_fed_t_constrain(self, i, value)
    }
    #[inline]
    pub unsafe fn constrain1(&mut self, i: cindex_t, j: cindex_t, c: raw_t) -> bool {
        dbm_fed_t_constrain1(self, i, j, c)
    }
    #[inline]
    pub unsafe fn constrain2(&mut self, i: cindex_t, j: cindex_t, b: i32, s: strictness_t) -> bool {
        dbm_fed_t_constrain2(self, i, j, b, s)
    }
    #[inline]
    pub unsafe fn constrain3(&mut self, i: cindex_t, j: cindex_t, b: i32, isStrict: bool) -> bool {
        dbm_fed_t_constrain3(self, i, j, b, isStrict)
    }
    #[inline]
    pub unsafe fn constrain4(&mut self, c: *const constraint_t) -> bool {
        dbm_fed_t_constrain4(self, c)
    }
    #[inline]
    pub unsafe fn constrain5(&mut self, c: *const constraint_t, n: size_t) -> bool {
        dbm_fed_t_constrain5(self, c, n)
    }
    #[inline]
    pub unsafe fn constrain6(
        &mut self,
        table: *const cindex_t,
        c: *const constraint_t,
        n: size_t,
    ) -> bool {
        dbm_fed_t_constrain6(self, table, c, n)
    }
    #[inline]
    pub unsafe fn constrain7(
        &mut self,
        table: *const cindex_t,
        arg1: *const base_pointer_t<constraint_t>,
    ) -> bool {
        dbm_fed_t_constrain7(self, table, arg1)
    }
    #[inline]
    pub unsafe fn constrain8(
        &mut self,
        table: *const cindex_t,
        arg1: *const [u64; 3usize],
    ) -> bool {
        dbm_fed_t_constrain8(self, table, arg1)
    }
    #[inline]
    pub unsafe fn intersects(&self, arg1: *const dbm_fed_t) -> bool {
        dbm_fed_t_intersects(self, arg1)
    }
    #[inline]
    pub unsafe fn intersects1(&self, arg1: *const dbm_dbm_t) -> bool {
        dbm_fed_t_intersects1(self, arg1)
    }
    #[inline]
    pub unsafe fn intersects2(&self, arg1: *const raw_t, dim: cindex_t) -> bool {
        dbm_fed_t_intersects2(self, arg1, dim)
    }
    #[inline]
    pub unsafe fn up(&mut self) -> *mut dbm_fed_t {
        dbm_fed_t_up(self)
    }
    #[inline]
    pub unsafe fn upStop(&mut self, stopped: *const u32) -> *mut dbm_fed_t {
        dbm_fed_t_upStop(self, stopped)
    }
    #[inline]
    pub unsafe fn down(&mut self) -> *mut dbm_fed_t {
        dbm_fed_t_down(self)
    }
    #[inline]
    pub unsafe fn downStop(&mut self, stopped: *const u32) -> *mut dbm_fed_t {
        dbm_fed_t_downStop(self, stopped)
    }
    #[inline]
    pub unsafe fn freeClock(&mut self, clock: cindex_t) -> *mut dbm_fed_t {
        dbm_fed_t_freeClock(self, clock)
    }
    #[inline]
    pub unsafe fn freeUp(&mut self, clock: cindex_t) -> *mut dbm_fed_t {
        dbm_fed_t_freeUp(self, clock)
    }
    #[inline]
    pub unsafe fn freeDown(&mut self, clock: cindex_t) -> *mut dbm_fed_t {
        dbm_fed_t_freeDown(self, clock)
    }
    #[inline]
    pub unsafe fn freeAllUp(&mut self) -> *mut dbm_fed_t {
        dbm_fed_t_freeAllUp(self)
    }
    #[inline]
    pub unsafe fn freeAllDown(&mut self) -> *mut dbm_fed_t {
        dbm_fed_t_freeAllDown(self)
    }
    #[inline]
    pub unsafe fn updateValue(&mut self, x: cindex_t, v: i32) {
        dbm_fed_t_updateValue(self, x, v)
    }
    #[inline]
    pub unsafe fn updateClock(&mut self, x: cindex_t, y: cindex_t) {
        dbm_fed_t_updateClock(self, x, y)
    }
    #[inline]
    pub unsafe fn updateIncrement(&mut self, x: cindex_t, v: i32) {
        dbm_fed_t_updateIncrement(self, x, v)
    }
    #[inline]
    pub unsafe fn update(&mut self, x: cindex_t, y: cindex_t, v: i32) {
        dbm_fed_t_update(self, x, y, v)
    }
    #[inline]
    pub unsafe fn satisfies(&self, i: cindex_t, j: cindex_t, c: raw_t) -> bool {
        dbm_fed_t_satisfies(self, i, j, c)
    }
    #[inline]
    pub unsafe fn satisfies1(&self, c: *const constraint_t) -> bool {
        dbm_fed_t_satisfies1(self, c)
    }
    #[inline]
    pub unsafe fn isUnbounded(&self) -> bool {
        dbm_fed_t_isUnbounded(self)
    }
    #[inline]
    pub unsafe fn getUnbounded(&self) -> dbm_fed_t {
        dbm_fed_t_getUnbounded(self)
    }
    #[inline]
    pub unsafe fn getBounded(&self) -> dbm_fed_t {
        dbm_fed_t_getBounded(self)
    }
    #[inline]
    pub unsafe fn relaxUp(&mut self) -> *mut dbm_fed_t {
        dbm_fed_t_relaxUp(self)
    }
    #[inline]
    pub unsafe fn relaxDown(&mut self) -> *mut dbm_fed_t {
        dbm_fed_t_relaxDown(self)
    }
    #[inline]
    pub unsafe fn tightenDown(&mut self) -> *mut dbm_fed_t {
        dbm_fed_t_tightenDown(self)
    }
    #[inline]
    pub unsafe fn tightenUp(&mut self) -> *mut dbm_fed_t {
        dbm_fed_t_tightenUp(self)
    }
    #[inline]
    pub unsafe fn relaxUpClock(&mut self, clock: cindex_t) -> *mut dbm_fed_t {
        dbm_fed_t_relaxUpClock(self, clock)
    }
    #[inline]
    pub unsafe fn relaxDownClock(&mut self, clock: cindex_t) -> *mut dbm_fed_t {
        dbm_fed_t_relaxDownClock(self, clock)
    }
    #[inline]
    pub unsafe fn relaxAll(&mut self) -> *mut dbm_fed_t {
        dbm_fed_t_relaxAll(self)
    }
    #[inline]
    pub unsafe fn reduce(&mut self) -> *mut dbm_fed_t {
        dbm_fed_t_reduce(self)
    }
    #[inline]
    pub unsafe fn noReduce(&mut self) -> *mut dbm_fed_t {
        dbm_fed_t_noReduce(self)
    }
    #[inline]
    pub unsafe fn expensiveReduce(&mut self) -> *mut dbm_fed_t {
        dbm_fed_t_expensiveReduce(self)
    }
    #[inline]
    pub unsafe fn mergeReduce(
        &mut self,
        skip: size_t,
        level: ::std::os::raw::c_int,
    ) -> *mut dbm_fed_t {
        dbm_fed_t_mergeReduce(self, skip, level)
    }
    #[inline]
    pub unsafe fn heuristicMergeReduce(active: bool) {
        dbm_fed_t_heuristicMergeReduce(active)
    }
    #[inline]
    pub unsafe fn convexReduce(&mut self) -> *mut dbm_fed_t {
        dbm_fed_t_convexReduce(self)
    }
    #[inline]
    pub unsafe fn expensiveConvexReduce(&mut self) -> *mut dbm_fed_t {
        dbm_fed_t_expensiveConvexReduce(self)
    }
    #[inline]
    pub unsafe fn partitionReduce(&mut self) -> *mut dbm_fed_t {
        dbm_fed_t_partitionReduce(self)
    }
    #[inline]
    pub unsafe fn contains(&self, point: *const dbm_IntValuation) -> bool {
        dbm_fed_t_contains(self, point)
    }
    #[inline]
    pub unsafe fn contains1(&self, point: *const i32, dim: cindex_t) -> bool {
        dbm_fed_t_contains1(self, point, dim)
    }
    #[inline]
    pub unsafe fn contains2(&self, point: *const dbm_DoubleValuation) -> bool {
        dbm_fed_t_contains2(self, point)
    }
    #[inline]
    pub unsafe fn contains3(&self, point: *const f64, dim: cindex_t) -> bool {
        dbm_fed_t_contains3(self, point, dim)
    }
    #[inline]
    pub unsafe fn possibleBackDelay(&self, point: *const dbm_DoubleValuation) -> f64 {
        dbm_fed_t_possibleBackDelay(self, point)
    }
    #[inline]
    pub unsafe fn possibleBackDelay1(&self, point: *const f64, dim: cindex_t) -> f64 {
        dbm_fed_t_possibleBackDelay1(self, point, dim)
    }
    #[inline]
    pub unsafe fn getMinDelay(
        &self,
        point: *const dbm_DoubleValuation,
        t: *mut f64,
        minVal: *mut f64,
        minStrict: *mut bool,
        stopped: *const u32,
    ) -> bool {
        dbm_fed_t_getMinDelay(self, point, t, minVal, minStrict, stopped)
    }
    #[inline]
    pub unsafe fn getMinDelay1(
        &self,
        point: *const f64,
        dim: cindex_t,
        t: *mut f64,
        minVal: *mut f64,
        minStrict: *mut bool,
        stopped: *const u32,
    ) -> bool {
        dbm_fed_t_getMinDelay1(self, point, dim, t, minVal, minStrict, stopped)
    }
    #[inline]
    pub unsafe fn getMaxBackDelay(
        &self,
        point: *const dbm_DoubleValuation,
        t: *mut f64,
        max: f64,
    ) -> bool {
        dbm_fed_t_getMaxBackDelay(self, point, t, max)
    }
    #[inline]
    pub unsafe fn getMaxBackDelay1(
        &self,
        point: *const f64,
        dim: cindex_t,
        t: *mut f64,
        max: f64,
    ) -> bool {
        dbm_fed_t_getMaxBackDelay1(self, point, dim, t, max)
    }
    #[inline]
    pub unsafe fn getDelay(
        &self,
        point: *const dbm_DoubleValuation,
        min: *mut f64,
        max: *mut f64,
        minVal: *mut f64,
        minStrict: *mut bool,
        maxVal: *mut f64,
        maxStrict: *mut bool,
        stopped: *const u32,
    ) -> bool {
        dbm_fed_t_getDelay(
            self, point, min, max, minVal, minStrict, maxVal, maxStrict, stopped,
        )
    }
    #[inline]
    pub unsafe fn getDelay1(
        &self,
        point: *const f64,
        dim: cindex_t,
        min: *mut f64,
        max: *mut f64,
        minVal: *mut f64,
        minStrict: *mut bool,
        maxVal: *mut f64,
        maxStrict: *mut bool,
        stopped: *const u32,
    ) -> bool {
        dbm_fed_t_getDelay1(
            self, point, dim, min, max, minVal, minStrict, maxVal, maxStrict, stopped,
        )
    }
    #[inline]
    pub unsafe fn isConstrainedBy(&self, arg1: cindex_t, arg2: cindex_t, arg3: raw_t) -> bool {
        dbm_fed_t_isConstrainedBy(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn extrapolateMaxBounds(&mut self, max: *const i32) {
        dbm_fed_t_extrapolateMaxBounds(self, max)
    }
    #[inline]
    pub unsafe fn diagonalExtrapolateMaxBounds(&mut self, max: *const i32) {
        dbm_fed_t_diagonalExtrapolateMaxBounds(self, max)
    }
    #[inline]
    pub unsafe fn extrapolateLUBounds(&mut self, lower: *const i32, upper: *const i32) {
        dbm_fed_t_extrapolateLUBounds(self, lower, upper)
    }
    #[inline]
    pub unsafe fn diagonalExtrapolateLUBounds(&mut self, lower: *const i32, upper: *const i32) {
        dbm_fed_t_diagonalExtrapolateLUBounds(self, lower, upper)
    }
    #[inline]
    pub unsafe fn splitExtrapolate(
        &mut self,
        begin: *const constraint_t,
        end: *const constraint_t,
        max: *const i32,
    ) {
        dbm_fed_t_splitExtrapolate(self, begin, end, max)
    }
    #[inline]
    pub unsafe fn resize(
        &mut self,
        bitSrc: *const u32,
        bitDst: *const u32,
        bitSize: size_t,
        table: *mut cindex_t,
    ) {
        dbm_fed_t_resize(self, bitSrc, bitDst, bitSize, table)
    }
    #[inline]
    pub unsafe fn changeClocks(&mut self, target: *const cindex_t, newDim: cindex_t) {
        dbm_fed_t_changeClocks(self, target, newDim)
    }
    #[inline]
    pub unsafe fn swapClocks(&mut self, x: cindex_t, y: cindex_t) {
        dbm_fed_t_swapClocks(self, x, y)
    }
    #[inline]
    pub unsafe fn getValuation(
        &self,
        cval: *mut dbm_DoubleValuation,
        freeC: *mut bool,
    ) -> *mut dbm_DoubleValuation {
        dbm_fed_t_getValuation(self, cval, freeC)
    }
    #[inline]
    pub unsafe fn predt(
        &mut self,
        bad: *const dbm_fed_t,
        restrict: *const raw_t,
    ) -> *mut dbm_fed_t {
        dbm_fed_t_predt(self, bad, restrict)
    }
    #[inline]
    pub unsafe fn predt1(
        &mut self,
        bad: *const dbm_dbm_t,
        restrict: *const raw_t,
    ) -> *mut dbm_fed_t {
        dbm_fed_t_predt1(self, bad, restrict)
    }
    #[inline]
    pub unsafe fn predt2(
        &mut self,
        bad: *const raw_t,
        dim: cindex_t,
        restrict: *const raw_t,
    ) -> *mut dbm_fed_t {
        dbm_fed_t_predt2(self, bad, dim, restrict)
    }
    #[inline]
    pub unsafe fn isIncludedInPredt(&self, good: *const dbm_fed_t, bad: *const dbm_fed_t) -> bool {
        dbm_fed_t_isIncludedInPredt(self, good, bad)
    }
    #[inline]
    pub unsafe fn has(&self, arg: *const dbm_dbm_t) -> bool {
        dbm_fed_t_has(self, arg)
    }
    #[inline]
    pub unsafe fn has1(&self, arg: *const raw_t, dim: cindex_t) -> bool {
        dbm_fed_t_has1(self, arg, dim)
    }
    #[inline]
    pub unsafe fn hasSame(&self, arg: *const dbm_dbm_t) -> bool {
        dbm_fed_t_hasSame(self, arg)
    }
    #[inline]
    pub unsafe fn removeIncludedIn(&mut self, arg: *const dbm_fed_t) {
        dbm_fed_t_removeIncludedIn(self, arg)
    }
    #[inline]
    pub unsafe fn removeIncludedIn1(&mut self, arg: *const dbm_dbm_t) -> bool {
        dbm_fed_t_removeIncludedIn1(self, arg)
    }
    #[inline]
    pub unsafe fn removeIncludedIn2(&mut self, arg: *const raw_t, dim: cindex_t) -> bool {
        dbm_fed_t_removeIncludedIn2(self, arg, dim)
    }
    #[inline]
    pub unsafe fn isSubtractionEmpty(&self, arg: *const raw_t, dim: cindex_t) -> bool {
        dbm_fed_t_isSubtractionEmpty(self, arg, dim)
    }
    #[inline]
    pub unsafe fn isSubtractionEmpty1(&self, arg: *const dbm_dbm_t) -> bool {
        dbm_fed_t_isSubtractionEmpty1(self, arg)
    }
    #[inline]
    pub unsafe fn isSubtractionEmpty2(&self, arg: *const dbm_fed_t) -> bool {
        dbm_fed_t_isSubtractionEmpty2(self, arg)
    }
    #[inline]
    pub unsafe fn isSubtractionEmpty3(
        dbm: *const raw_t,
        dim: cindex_t,
        fed: *const dbm_fed_t,
    ) -> bool {
        dbm_fed_t_isSubtractionEmpty3(dbm, dim, fed)
    }
    #[inline]
    pub unsafe fn subtract(arg1: *const raw_t, arg2: *const raw_t, dim: cindex_t) -> dbm_fed_t {
        dbm_fed_t_subtract(arg1, arg2, dim)
    }
    #[inline]
    pub unsafe fn subtract1(arg1: *const dbm_dbm_t, arg2: *const raw_t) -> dbm_fed_t {
        dbm_fed_t_subtract1(arg1, arg2)
    }
    #[inline]
    pub unsafe fn subtract2(arg1: *const dbm_dbm_t, arg2: *const dbm_dbm_t) -> dbm_fed_t {
        dbm_fed_t_subtract2(arg1, arg2)
    }
    #[inline]
    pub unsafe fn toLowerBounds(&self) -> dbm_fed_t {
        dbm_fed_t_toLowerBounds(self)
    }
    #[inline]
    pub unsafe fn toUpperBounds(&self) -> dbm_fed_t {
        dbm_fed_t_toUpperBounds(self)
    }
    #[inline]
    pub unsafe fn getMaxUpper(&self, arg1: cindex_t) -> raw_t {
        dbm_fed_t_getMaxUpper(self, arg1)
    }
    #[inline]
    pub unsafe fn getMaxLower(&self, arg1: cindex_t) -> raw_t {
        dbm_fed_t_getMaxLower(self, arg1)
    }
    #[inline]
    pub unsafe fn removeEmpty(&mut self) {
        dbm_fed_t_removeEmpty(self)
    }
    #[inline]
    pub unsafe fn hasEmpty(&self) -> bool {
        dbm_fed_t_hasEmpty(self)
    }
    #[inline]
    pub unsafe fn begin(&self) -> dbm_fed_t_const_iterator {
        dbm_fed_t_begin(self)
    }
    #[inline]
    pub unsafe fn end(&self) -> dbm_fed_t_const_iterator {
        dbm_fed_t_end(self)
    }
    #[inline]
    pub unsafe fn beginMutable(&mut self) -> dbm_fed_t_iterator {
        dbm_fed_t_beginMutable(self)
    }
    #[inline]
    pub unsafe fn endMutable(&self) -> dbm_fed_t_iterator {
        dbm_fed_t_endMutable(self)
    }
    #[inline]
    pub unsafe fn erase(&mut self, iter: *mut dbm_fed_t_iterator) -> dbm_fed_t_iterator {
        dbm_fed_t_erase(self, iter)
    }
    #[inline]
    pub unsafe fn write(&mut self, mem: *mut *mut dbm_fdbm_t) -> size_t {
        dbm_fed_t_write(self, mem)
    }
    #[inline]
    pub unsafe fn read(&mut self, fed: *mut *mut dbm_fdbm_t, size: size_t) {
        dbm_fed_t_read(self, fed, size)
    }
    #[inline]
    pub unsafe fn const_dbmt(&self) -> *const dbm_dbm_t {
        dbm_fed_t_const_dbmt(self)
    }
    #[inline]
    pub unsafe fn dbmt(&mut self) -> *mut dbm_dbm_t {
        dbm_fed_t_dbmt(self)
    }
    #[inline]
    pub unsafe fn removeThisDBM(&mut self, dbm: *const dbm_dbm_t) -> bool {
        dbm_fed_t_removeThisDBM(self, dbm)
    }
    #[inline]
    pub unsafe fn setMutable(&mut self) {
        dbm_fed_t_setMutable(self)
    }
    #[inline]
    pub unsafe fn ifed(&mut self) -> *mut dbm_ifed_t {
        dbm_fed_t_ifed(self)
    }
    #[inline]
    pub unsafe fn ifed1(&self) -> *const dbm_ifed_t {
        dbm_fed_t_ifed1(self)
    }
    #[inline]
    pub unsafe fn new(dim: cindex_t) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        dbm_fed_t_fed_t(__bindgen_tmp.as_mut_ptr(), dim);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg: *const dbm_fed_t) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        dbm_fed_t_fed_t1(__bindgen_tmp.as_mut_ptr(), arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg: *const dbm_dbm_t) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        dbm_fed_t_fed_t2(__bindgen_tmp.as_mut_ptr(), arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(arg: *const raw_t, dim: cindex_t) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        dbm_fed_t_fed_t3(__bindgen_tmp.as_mut_ptr(), arg, dim);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(op: *const dbm_ClockOperation<dbm_fed_t>) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        dbm_fed_t_fed_t4(__bindgen_tmp.as_mut_ptr(), op);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        dbm_fed_t_fed_t_destructor(self)
    }
}
#[doc = " idbm_t: internal DBM -- to be used in DBMTable *"]
#[repr(C)]
#[derive(Debug)]
pub struct dbm_idbm_t {
    pub _base: Bucket_t,
    pub refCounter: u32,
    pub matrix: __IncompleteArrayField<raw_t>,
}
pub const dbm_idbm_t_HASHED_BIT: dbm_idbm_t__bindgen_ty_1 = -2147483648;
pub const dbm_idbm_t_HASH_MASK: dbm_idbm_t__bindgen_ty_1 = 2147450880;
pub const dbm_idbm_t_DIM_MASK: dbm_idbm_t__bindgen_ty_1 = 32767;
#[doc = " Maximal dimension == 2^15-1"]
#[doc = " because (2^15)^2 == 2^30 constraints == 2^32 bytes"]
#[doc = " and we are in big big trouble then."]
#[doc = " MAX_DIM is the maximum dimension *and* the access mask."]
#[doc = " HASH_MASK contains the remaining bits for the hash value"]
#[doc = " HASHED_BIT mark if this DBM is in a hash tabled (hashed)."]
pub type dbm_idbm_t__bindgen_ty_1 = i32;
#[test]
fn bindgen_test_layout_dbm_idbm_t() {
    assert_eq!(
        ::std::mem::size_of::<dbm_idbm_t>(),
        24usize,
        concat!("Size of: ", stringify!(dbm_idbm_t))
    );
    assert_eq!(
        ::std::mem::align_of::<dbm_idbm_t>(),
        8usize,
        concat!("Alignment of ", stringify!(dbm_idbm_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dbm_idbm_t>())).refCounter as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(dbm_idbm_t),
            "::",
            stringify!(refCounter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dbm_idbm_t>())).matrix as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dbm_idbm_t),
            "::",
            stringify!(matrix)
        )
    );
}
extern "C" {
    #[doc = " @return dimension of this DBM."]
    #[link_name = "\u{1}getDimension"]
    pub fn dbm_idbm_t_getDimension(this: *const dbm_idbm_t) -> cindex_t;
}
extern "C" {
    #[doc = " @return a freshly computed hash value"]
    #[link_name = "\u{1}hash"]
    pub fn dbm_idbm_t_hash(this: *const dbm_idbm_t, seed: u32) -> u32;
}
extern "C" {
    #[doc = " @return true if this DBM is in a hash table"]
    #[link_name = "\u{1}isHashed"]
    pub fn dbm_idbm_t_isHashed(this: *const dbm_idbm_t) -> bool;
}
extern "C" {
    #[doc = " @return true if this dbm can be modified."]
    #[link_name = "\u{1}isMutable"]
    pub fn dbm_idbm_t_isMutable(this: *const dbm_idbm_t) -> bool;
}
extern "C" {
    #[doc = " Check if this dimPtr is mutable and try to make it so cheaply."]
    #[link_name = "\u{1}tryMutable"]
    pub fn dbm_idbm_t_tryMutable(this: *mut dbm_idbm_t) -> bool;
}
extern "C" {
    #[doc = " Unhash itself."]
    #[doc = " @pre refCounter == 1 && isHashed()"]
    #[link_name = "\u{1}unhash"]
    pub fn dbm_idbm_t_unhash(this: *mut dbm_idbm_t);
}
extern "C" {
    #[doc = " @return recomputed hash value for this DBM"]
    #[doc = " and save it partially."]
    #[link_name = "\u{1}updateHash"]
    pub fn dbm_idbm_t_updateHash(this: *mut dbm_idbm_t, seed: u32) -> u32;
}
extern "C" {
    #[doc = " Mark 'this' as hashed"]
    #[link_name = "\u{1}markHashed"]
    pub fn dbm_idbm_t_markHashed(this: *mut dbm_idbm_t);
}
extern "C" {
    #[doc = " Unmark 'this' as hashed"]
    #[link_name = "\u{1}unmarkHashed"]
    pub fn dbm_idbm_t_unmarkHashed(this: *mut dbm_idbm_t);
}
extern "C" {
    #[doc = " Increment reference counter."]
    #[link_name = "\u{1}incRef"]
    pub fn dbm_idbm_t_incRef(this: *mut dbm_idbm_t);
}
extern "C" {
    #[doc = " Decrement reference counter."]
    #[doc = " @post 'this' may be deallocated."]
    #[link_name = "\u{1}decRef"]
    pub fn dbm_idbm_t_decRef(this: *mut dbm_idbm_t);
}
extern "C" {
    #[doc = " Simple decRef without remove() @pre refCounter > 1"]
    #[link_name = "\u{1}decRefImmutable"]
    pub fn dbm_idbm_t_decRefImmutable(this: *mut dbm_idbm_t);
}
extern "C" {
    #[doc = " Simple remove for mutable idbm_t. @pre isMutable()"]
    #[link_name = "\u{1}removeMutable"]
    pub fn dbm_idbm_t_removeMutable(this: *mut dbm_idbm_t);
}
extern "C" {
    #[doc = " Deallocate this idbm_t."]
    #[doc = " @pre refCounter == 0"]
    #[doc = " Not inlined since the call is present very often"]
    #[doc = " for every decRef, where decRef is called for"]
    #[doc = " garbage collection."]
    #[link_name = "\u{1}remove"]
    pub fn dbm_idbm_t_remove(this: *mut dbm_idbm_t);
}
extern "C" {
    #[doc = " @return writable DBM matrix, @pre isMutable()"]
    #[link_name = "\u{1}dbm"]
    pub fn dbm_idbm_t_dbm(this: *mut dbm_idbm_t) -> *mut raw_t;
}
extern "C" {
    #[doc = " @return read-only DBM matrix."]
    #[link_name = "\u{1}const_dbm"]
    pub fn dbm_idbm_t_const_dbm(this: *const dbm_idbm_t) -> *const raw_t;
}
extern "C" {
    #[doc = " @return DBM matrix without pre-condition, careful..."]
    #[link_name = "\u{1}getMatrix"]
    pub fn dbm_idbm_t_getMatrix(this: *mut dbm_idbm_t) -> *mut raw_t;
}
extern "C" {
    #[doc = " @return newly allocated idbm_t, @param dim: DBM dimension."]
    #[link_name = "\u{1}create"]
    pub fn dbm_idbm_t_create(dim: cindex_t) -> *mut dbm_idbm_t;
}
extern "C" {
    #[doc = " @return newly allocated idbm_t, @param arg: original to copy."]
    #[link_name = "\u{1}create"]
    pub fn dbm_idbm_t_create1(arg: *const dbm_idbm_t) -> *mut dbm_idbm_t;
}
extern "C" {
    #[doc = " Constructor: use placement constructor"]
    #[doc = " to instantiate."]
    #[doc = " @param dim: dimension of the DBM."]
    #[doc = " @pre dim < 2^16, reasonable since such a"]
    #[doc = " DBM would have 2^32 elements and we cannot"]
    #[doc = " use a single such DBM."]
    #[doc = " @post DBM is not initialized!"]
    #[link_name = "\u{1}idbm_t"]
    pub fn dbm_idbm_t_idbm_t(this: *mut dbm_idbm_t, dim: cindex_t);
}
extern "C" {
    #[doc = " Constructor by copy: useful to get a mutable copy"]
    #[doc = " of this DBM."]
    #[doc = " @param original: DBM to copy."]
    #[link_name = "\u{1}idbm_t"]
    pub fn dbm_idbm_t_idbm_t1(this: *mut dbm_idbm_t, original: *const dbm_idbm_t);
}
impl dbm_idbm_t {
    #[inline]
    pub unsafe fn getDimension(&self) -> cindex_t {
        dbm_idbm_t_getDimension(self)
    }
    #[inline]
    pub unsafe fn hash(&self, seed: u32) -> u32 {
        dbm_idbm_t_hash(self, seed)
    }
    #[inline]
    pub unsafe fn isHashed(&self) -> bool {
        dbm_idbm_t_isHashed(self)
    }
    #[inline]
    pub unsafe fn isMutable(&self) -> bool {
        dbm_idbm_t_isMutable(self)
    }
    #[inline]
    pub unsafe fn tryMutable(&mut self) -> bool {
        dbm_idbm_t_tryMutable(self)
    }
    #[inline]
    pub unsafe fn unhash(&mut self) {
        dbm_idbm_t_unhash(self)
    }
    #[inline]
    pub unsafe fn updateHash(&mut self, seed: u32) -> u32 {
        dbm_idbm_t_updateHash(self, seed)
    }
    #[inline]
    pub unsafe fn markHashed(&mut self) {
        dbm_idbm_t_markHashed(self)
    }
    #[inline]
    pub unsafe fn unmarkHashed(&mut self) {
        dbm_idbm_t_unmarkHashed(self)
    }
    #[inline]
    pub unsafe fn incRef(&mut self) {
        dbm_idbm_t_incRef(self)
    }
    #[inline]
    pub unsafe fn decRef(&mut self) {
        dbm_idbm_t_decRef(self)
    }
    #[inline]
    pub unsafe fn decRefImmutable(&mut self) {
        dbm_idbm_t_decRefImmutable(self)
    }
    #[inline]
    pub unsafe fn removeMutable(&mut self) {
        dbm_idbm_t_removeMutable(self)
    }
    #[inline]
    pub unsafe fn remove(&mut self) {
        dbm_idbm_t_remove(self)
    }
    #[inline]
    pub unsafe fn dbm(&mut self) -> *mut raw_t {
        dbm_idbm_t_dbm(self)
    }
    #[inline]
    pub unsafe fn const_dbm(&self) -> *const raw_t {
        dbm_idbm_t_const_dbm(self)
    }
    #[inline]
    pub unsafe fn getMatrix(&mut self) -> *mut raw_t {
        dbm_idbm_t_getMatrix(self)
    }
    #[inline]
    pub unsafe fn create(dim: cindex_t) -> *mut dbm_idbm_t {
        dbm_idbm_t_create(dim)
    }
    #[inline]
    pub unsafe fn create1(arg: *const dbm_idbm_t) -> *mut dbm_idbm_t {
        dbm_idbm_t_create1(arg)
    }
    #[inline]
    pub unsafe fn new(dim: cindex_t) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        dbm_idbm_t_idbm_t(__bindgen_tmp.as_mut_ptr(), dim);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(original: *const dbm_idbm_t) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        dbm_idbm_t_idbm_t1(__bindgen_tmp.as_mut_ptr(), original);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " Federation of DBMs: list containing individual DBMs. *"]
#[repr(C)]
#[derive(Debug)]
pub struct dbm_fdbm_t {
    pub next: *mut dbm_fdbm_t,
    pub idbm: dbm_dbm_t,
}
#[test]
fn bindgen_test_layout_dbm_fdbm_t() {
    assert_eq!(
        ::std::mem::size_of::<dbm_fdbm_t>(),
        16usize,
        concat!("Size of: ", stringify!(dbm_fdbm_t))
    );
    assert_eq!(
        ::std::mem::align_of::<dbm_fdbm_t>(),
        8usize,
        concat!("Alignment of ", stringify!(dbm_fdbm_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dbm_fdbm_t>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dbm_fdbm_t),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dbm_fdbm_t>())).idbm as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dbm_fdbm_t),
            "::",
            stringify!(idbm)
        )
    );
}
extern "C" {
    #[doc = " Copy a DBM into a newly created fdbm_t."]
    #[doc = " @param adbm: the DBM to copy."]
    #[doc = " @param nxt: list of DBMs to append."]
    #[link_name = "\u{1}create"]
    pub fn dbm_fdbm_t_create(
        adbm: *const raw_t,
        dim: cindex_t,
        nxt: *mut dbm_fdbm_t,
    ) -> *mut dbm_fdbm_t;
}
extern "C" {
    #[link_name = "\u{1}create"]
    pub fn dbm_fdbm_t_create1(adbm: *const dbm_dbm_t, nxt: *mut dbm_fdbm_t) -> *mut dbm_fdbm_t;
}
extern "C" {
    #[doc = " Copy start and append end to the copy."]
    #[link_name = "\u{1}copy"]
    pub fn dbm_fdbm_t_copy(start: *const dbm_fdbm_t, end: *mut dbm_fdbm_t) -> *mut dbm_fdbm_t;
}
extern "C" {
    #[doc = " Wrapper methods."]
    #[link_name = "\u{1}copy"]
    pub fn dbm_fdbm_t_copy1(this: *const dbm_fdbm_t) -> *mut dbm_fdbm_t;
}
extern "C" {
    #[link_name = "\u{1}isEmpty"]
    pub fn dbm_fdbm_t_isEmpty(this: *const dbm_fdbm_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}getDimension"]
    pub fn dbm_fdbm_t_getDimension(this: *const dbm_fdbm_t) -> cindex_t;
}
extern "C" {
    #[doc = " Remove the list starting at fhead."]
    #[link_name = "\u{1}removeAll"]
    pub fn dbm_fdbm_t_removeAll(fhead: *mut dbm_fdbm_t);
}
extern "C" {
    #[doc = " Remove this fdbm_t and its DBM."]
    #[link_name = "\u{1}remove"]
    pub fn dbm_fdbm_t_remove(this: *mut dbm_fdbm_t);
}
extern "C" {
    #[doc = " Remove this fdbm_t with @pre isEmpty()"]
    #[link_name = "\u{1}removeEmpty"]
    pub fn dbm_fdbm_t_removeEmpty(this: *mut dbm_fdbm_t);
}
extern "C" {
    #[doc = " Compute list size."]
    #[link_name = "\u{1}size"]
    pub fn dbm_fdbm_t_size(this: *const dbm_fdbm_t) -> size_t;
}
extern "C" {
    #[doc = " @return the internal DBM."]
    #[link_name = "\u{1}const_dbmt"]
    pub fn dbm_fdbm_t_const_dbmt(this: *const dbm_fdbm_t) -> *const dbm_dbm_t;
}
extern "C" {
    #[link_name = "\u{1}dbmt"]
    pub fn dbm_fdbm_t_dbmt(this: *mut dbm_fdbm_t) -> *mut dbm_dbm_t;
}
extern "C" {
    #[doc = " Unchecked access."]
    #[link_name = "\u{1}getMatrix"]
    pub fn dbm_fdbm_t_getMatrix(this: *mut dbm_fdbm_t) -> *mut raw_t;
}
extern "C" {
    #[doc = " @return start appended with end."]
    #[link_name = "\u{1}append"]
    pub fn dbm_fdbm_t_append(start: *mut dbm_fdbm_t, end: *mut dbm_fdbm_t) -> *mut dbm_fdbm_t;
}
extern "C" {
    #[doc = " @return next for iterations."]
    #[link_name = "\u{1}getNextMutable"]
    pub fn dbm_fdbm_t_getNextMutable(this: *mut dbm_fdbm_t) -> *mut *mut dbm_fdbm_t;
}
extern "C" {
    #[link_name = "\u{1}getNext"]
    pub fn dbm_fdbm_t_getNext(this: *const dbm_fdbm_t) -> *const dbm_fdbm_t;
}
extern "C" {
    #[link_name = "\u{1}getNext"]
    pub fn dbm_fdbm_t_getNext1(this: *mut dbm_fdbm_t) -> *mut dbm_fdbm_t;
}
extern "C" {
    #[doc = " Test its next pointer."]
    #[link_name = "\u{1}hasNext"]
    pub fn dbm_fdbm_t_hasNext(this: *const dbm_fdbm_t, nxt: *mut *mut dbm_fdbm_t) -> bool;
}
extern "C" {
    #[doc = " Change next for iterations."]
    #[link_name = "\u{1}setNext"]
    pub fn dbm_fdbm_t_setNext(this: *mut dbm_fdbm_t, nxt: *mut dbm_fdbm_t);
}
extern "C" {
    #[doc = " Remove this and return next;"]
    #[link_name = "\u{1}removeAndNext"]
    pub fn dbm_fdbm_t_removeAndNext(this: *mut dbm_fdbm_t) -> *mut dbm_fdbm_t;
}
extern "C" {
    #[doc = " Remove this and return next;"]
    #[link_name = "\u{1}removeEmptyAndNext"]
    pub fn dbm_fdbm_t_removeEmptyAndNext(this: *mut dbm_fdbm_t) -> *mut dbm_fdbm_t;
}
impl dbm_fdbm_t {
    #[inline]
    pub unsafe fn create(
        adbm: *const raw_t,
        dim: cindex_t,
        nxt: *mut dbm_fdbm_t,
    ) -> *mut dbm_fdbm_t {
        dbm_fdbm_t_create(adbm, dim, nxt)
    }
    #[inline]
    pub unsafe fn create1(adbm: *const dbm_dbm_t, nxt: *mut dbm_fdbm_t) -> *mut dbm_fdbm_t {
        dbm_fdbm_t_create1(adbm, nxt)
    }
    #[inline]
    pub unsafe fn copy(start: *const dbm_fdbm_t, end: *mut dbm_fdbm_t) -> *mut dbm_fdbm_t {
        dbm_fdbm_t_copy(start, end)
    }
    #[inline]
    pub unsafe fn copy1(&self) -> *mut dbm_fdbm_t {
        dbm_fdbm_t_copy1(self)
    }
    #[inline]
    pub unsafe fn isEmpty(&self) -> bool {
        dbm_fdbm_t_isEmpty(self)
    }
    #[inline]
    pub unsafe fn getDimension(&self) -> cindex_t {
        dbm_fdbm_t_getDimension(self)
    }
    #[inline]
    pub unsafe fn removeAll(fhead: *mut dbm_fdbm_t) {
        dbm_fdbm_t_removeAll(fhead)
    }
    #[inline]
    pub unsafe fn remove(&mut self) {
        dbm_fdbm_t_remove(self)
    }
    #[inline]
    pub unsafe fn removeEmpty(&mut self) {
        dbm_fdbm_t_removeEmpty(self)
    }
    #[inline]
    pub unsafe fn size(&self) -> size_t {
        dbm_fdbm_t_size(self)
    }
    #[inline]
    pub unsafe fn const_dbmt(&self) -> *const dbm_dbm_t {
        dbm_fdbm_t_const_dbmt(self)
    }
    #[inline]
    pub unsafe fn dbmt(&mut self) -> *mut dbm_dbm_t {
        dbm_fdbm_t_dbmt(self)
    }
    #[inline]
    pub unsafe fn getMatrix(&mut self) -> *mut raw_t {
        dbm_fdbm_t_getMatrix(self)
    }
    #[inline]
    pub unsafe fn append(start: *mut dbm_fdbm_t, end: *mut dbm_fdbm_t) -> *mut dbm_fdbm_t {
        dbm_fdbm_t_append(start, end)
    }
    #[inline]
    pub unsafe fn getNextMutable(&mut self) -> *mut *mut dbm_fdbm_t {
        dbm_fdbm_t_getNextMutable(self)
    }
    #[inline]
    pub unsafe fn getNext(&self) -> *const dbm_fdbm_t {
        dbm_fdbm_t_getNext(self)
    }
    #[inline]
    pub unsafe fn getNext1(&mut self) -> *mut dbm_fdbm_t {
        dbm_fdbm_t_getNext1(self)
    }
    #[inline]
    pub unsafe fn hasNext(&self, nxt: *mut *mut dbm_fdbm_t) -> bool {
        dbm_fdbm_t_hasNext(self, nxt)
    }
    #[inline]
    pub unsafe fn setNext(&mut self, nxt: *mut dbm_fdbm_t) {
        dbm_fdbm_t_setNext(self, nxt)
    }
    #[inline]
    pub unsafe fn removeAndNext(&mut self) -> *mut dbm_fdbm_t {
        dbm_fdbm_t_removeAndNext(self)
    }
    #[inline]
    pub unsafe fn removeEmptyAndNext(&mut self) -> *mut dbm_fdbm_t {
        dbm_fdbm_t_removeEmptyAndNext(self)
    }
}
#[doc = " Simple list of DBMs for light-weight computations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dbm_dbmlist_t {
    pub fedSize: size_t,
    pub fhead: *mut dbm_fdbm_t,
}
#[test]
fn bindgen_test_layout_dbm_dbmlist_t() {
    assert_eq!(
        ::std::mem::size_of::<dbm_dbmlist_t>(),
        16usize,
        concat!("Size of: ", stringify!(dbm_dbmlist_t))
    );
    assert_eq!(
        ::std::mem::align_of::<dbm_dbmlist_t>(),
        8usize,
        concat!("Alignment of ", stringify!(dbm_dbmlist_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dbm_dbmlist_t>())).fedSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dbm_dbmlist_t),
            "::",
            stringify!(fedSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dbm_dbmlist_t>())).fhead as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dbm_dbmlist_t),
            "::",
            stringify!(fhead)
        )
    );
}
extern "C" {
    #[doc = " Append a list of fdbm_t."]
    #[link_name = "\u{1}append"]
    pub fn dbm_dbmlist_t_append(
        this: *mut dbm_dbmlist_t,
        arg: *mut dbm_dbmlist_t,
    ) -> *mut dbm_dbmlist_t;
}
extern "C" {
    #[link_name = "\u{1}appendBegin"]
    pub fn dbm_dbmlist_t_appendBegin(
        this: *mut dbm_dbmlist_t,
        arg: *mut dbm_dbmlist_t,
    ) -> *mut dbm_dbmlist_t;
}
extern "C" {
    #[link_name = "\u{1}appendEnd"]
    pub fn dbm_dbmlist_t_appendEnd(
        this: *mut dbm_dbmlist_t,
        arg: *mut dbm_dbmlist_t,
    ) -> *mut dbm_dbmlist_t;
}
extern "C" {
    #[doc = " Append just one fdbm_t, not the whole list!"]
    #[link_name = "\u{1}append"]
    pub fn dbm_dbmlist_t_append1(
        this: *mut dbm_dbmlist_t,
        arg: *mut dbm_fdbm_t,
    ) -> *mut dbm_dbmlist_t;
}
extern "C" {
    #[doc = " Append a copy of arg, @pre dimension is the same as the other DBMs."]
    #[link_name = "\u{1}append"]
    pub fn dbm_dbmlist_t_append2(
        this: *mut dbm_dbmlist_t,
        arg: *const raw_t,
        dim: cindex_t,
    ) -> *mut raw_t;
}
extern "C" {
    #[doc = " Remove DBMs of 'this' that are included in arg"]
    #[doc = " and DBMs of arg that are included in 'this'."]
    #[link_name = "\u{1}removeIncluded"]
    pub fn dbm_dbmlist_t_removeIncluded(this: *mut dbm_dbmlist_t, arg: *mut dbm_dbmlist_t);
}
extern "C" {
    #[doc = " Union of arg with this dbmlist_t, does inclusion checking"]
    #[doc = " @post dbmlist_t arg is invalid."]
    #[link_name = "\u{1}unionWith"]
    pub fn dbm_dbmlist_t_unionWith(
        this: *mut dbm_dbmlist_t,
        arg: *mut dbm_dbmlist_t,
    ) -> *mut dbm_dbmlist_t;
}
extern "C" {
    #[doc = " Simple reduction by inclusion check of DBMs."]
    #[link_name = "\u{1}reduce"]
    pub fn dbm_dbmlist_t_reduce(this: *mut dbm_dbmlist_t, dim: cindex_t);
}
extern "C" {
    #[doc = " Reduction by inclusion check + merge (by pairs) of DBMs."]
    #[link_name = "\u{1}mergeReduce"]
    pub fn dbm_dbmlist_t_mergeReduce(
        this: *mut dbm_dbmlist_t,
        dim: cindex_t,
        jumpj: size_t,
        expensiveTry: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @return the federation size."]
    #[link_name = "\u{1}size"]
    pub fn dbm_dbmlist_t_size(this: *const dbm_dbmlist_t) -> size_t;
}
extern "C" {
    #[doc = " Head of the list."]
    #[link_name = "\u{1}const_head"]
    pub fn dbm_dbmlist_t_const_head(this: *const dbm_dbmlist_t) -> *const dbm_fdbm_t;
}
extern "C" {
    #[link_name = "\u{1}head"]
    pub fn dbm_dbmlist_t_head(this: *mut dbm_dbmlist_t) -> *mut dbm_fdbm_t;
}
extern "C" {
    #[link_name = "\u{1}atHead"]
    pub fn dbm_dbmlist_t_atHead(this: *mut dbm_dbmlist_t) -> *mut *mut dbm_fdbm_t;
}
extern "C" {
    #[doc = " Update the federation size."]
    #[link_name = "\u{1}incSize"]
    pub fn dbm_dbmlist_t_incSize(this: *mut dbm_dbmlist_t, n: size_t);
}
extern "C" {
    #[link_name = "\u{1}decSize"]
    pub fn dbm_dbmlist_t_decSize(this: *mut dbm_dbmlist_t, n: size_t);
}
extern "C" {
    #[doc = " Brutal re-set of the list."]
    #[link_name = "\u{1}reset"]
    pub fn dbm_dbmlist_t_reset(this: *mut dbm_dbmlist_t, dbms: *mut dbm_fdbm_t, size: size_t);
}
extern "C" {
    #[link_name = "\u{1}reset"]
    pub fn dbm_dbmlist_t_reset1(this: *mut dbm_dbmlist_t, l: *mut dbm_dbmlist_t);
}
extern "C" {
    #[doc = " @return 'this' intersected with arg. @pre same dimension."]
    #[link_name = "\u{1}intersection"]
    pub fn dbm_dbmlist_t_intersection(
        this: *mut dbm_dbmlist_t,
        arg: *const raw_t,
        dim: cindex_t,
    ) -> *mut dbm_dbmlist_t;
}
extern "C" {
    #[link_name = "\u{1}intersection"]
    pub fn dbm_dbmlist_t_intersection1(
        this: *mut dbm_dbmlist_t,
        arg: *const dbm_dbm_t,
        dim: cindex_t,
    ) -> *mut dbm_dbmlist_t;
}
extern "C" {
    #[doc = " @return a simple copy of this list of DBMs."]
    #[link_name = "\u{1}copyList"]
    pub fn dbm_dbmlist_t_copyList(this: *const dbm_dbmlist_t) -> dbm_dbmlist_t;
}
extern "C" {
    #[doc = " Steal one DBM of a dbmlist_t."]
    #[link_name = "\u{1}steal"]
    pub fn dbm_dbmlist_t_steal(
        this: *mut dbm_dbmlist_t,
        dbm: *mut *mut dbm_fdbm_t,
        owner: *mut dbm_dbmlist_t,
    );
}
extern "C" {
    #[doc = " @pre head is somewhere in this list of DBMs"]
    #[link_name = "\u{1}steal"]
    pub fn dbm_dbmlist_t_steal1(
        this: *mut dbm_dbmlist_t,
        head: *mut *mut dbm_fdbm_t,
        dbm: *mut *mut dbm_fdbm_t,
        owner: *mut dbm_dbmlist_t,
    ) -> *mut *mut dbm_fdbm_t;
}
extern "C" {
    #[doc = " Steal a list and append it at the end."]
    #[link_name = "\u{1}stealFromToEnd"]
    pub fn dbm_dbmlist_t_stealFromToEnd(
        this: *mut dbm_dbmlist_t,
        next: *mut *mut dbm_fdbm_t,
        dbmList: *mut dbm_dbmlist_t,
    );
}
extern "C" {
    #[doc = " Swap DBM lists."]
    #[link_name = "\u{1}swap"]
    pub fn dbm_dbmlist_t_swap(this: *mut dbm_dbmlist_t, arg: *mut dbm_dbmlist_t);
}
extern "C" {
    #[doc = " Copy ref."]
    #[link_name = "\u{1}copyRef"]
    pub fn dbm_dbmlist_t_copyRef(this: *mut dbm_dbmlist_t, arg: *mut dbm_dbmlist_t);
}
extern "C" {
    #[doc = " Remove head of list. @pre size() > 0."]
    #[link_name = "\u{1}removeHead"]
    pub fn dbm_dbmlist_t_removeHead(this: *mut dbm_dbmlist_t);
}
extern "C" {
    #[doc = " Print for debugging only, use operator << on fed_t instead."]
    #[link_name = "\u{1}print"]
    pub fn dbm_dbmlist_t_print(this: *const dbm_dbmlist_t, os: *mut std_ostream);
}
extern "C" {
    #[link_name = "\u{1}err"]
    pub fn dbm_dbmlist_t_err(this: *const dbm_dbmlist_t);
}
extern "C" {
    #[link_name = "\u{1}out"]
    pub fn dbm_dbmlist_t_out(this: *const dbm_dbmlist_t);
}
extern "C" {
    #[link_name = "\u{1}dbmlist_t"]
    pub fn dbm_dbmlist_t_dbmlist_t(this: *mut dbm_dbmlist_t);
}
extern "C" {
    #[link_name = "\u{1}dbmlist_t"]
    pub fn dbm_dbmlist_t_dbmlist_t1(this: *mut dbm_dbmlist_t, size: size_t, flist: *mut dbm_fdbm_t);
}
extern "C" {
    #[link_name = "\u{1}dbmlist_t"]
    pub fn dbm_dbmlist_t_dbmlist_t2(this: *mut dbm_dbmlist_t, arg: *const raw_t, dim: cindex_t);
}
extern "C" {
    #[link_name = "\u{1}dbmlist_t"]
    pub fn dbm_dbmlist_t_dbmlist_t3(this: *mut dbm_dbmlist_t, arg: *const dbm_dbm_t);
}
impl dbm_dbmlist_t {
    #[inline]
    pub unsafe fn append(&mut self, arg: *mut dbm_dbmlist_t) -> *mut dbm_dbmlist_t {
        dbm_dbmlist_t_append(self, arg)
    }
    #[inline]
    pub unsafe fn appendBegin(&mut self, arg: *mut dbm_dbmlist_t) -> *mut dbm_dbmlist_t {
        dbm_dbmlist_t_appendBegin(self, arg)
    }
    #[inline]
    pub unsafe fn appendEnd(&mut self, arg: *mut dbm_dbmlist_t) -> *mut dbm_dbmlist_t {
        dbm_dbmlist_t_appendEnd(self, arg)
    }
    #[inline]
    pub unsafe fn append1(&mut self, arg: *mut dbm_fdbm_t) -> *mut dbm_dbmlist_t {
        dbm_dbmlist_t_append1(self, arg)
    }
    #[inline]
    pub unsafe fn append2(&mut self, arg: *const raw_t, dim: cindex_t) -> *mut raw_t {
        dbm_dbmlist_t_append2(self, arg, dim)
    }
    #[inline]
    pub unsafe fn removeIncluded(&mut self, arg: *mut dbm_dbmlist_t) {
        dbm_dbmlist_t_removeIncluded(self, arg)
    }
    #[inline]
    pub unsafe fn unionWith(&mut self, arg: *mut dbm_dbmlist_t) -> *mut dbm_dbmlist_t {
        dbm_dbmlist_t_unionWith(self, arg)
    }
    #[inline]
    pub unsafe fn reduce(&mut self, dim: cindex_t) {
        dbm_dbmlist_t_reduce(self, dim)
    }
    #[inline]
    pub unsafe fn mergeReduce(
        &mut self,
        dim: cindex_t,
        jumpj: size_t,
        expensiveTry: ::std::os::raw::c_int,
    ) {
        dbm_dbmlist_t_mergeReduce(self, dim, jumpj, expensiveTry)
    }
    #[inline]
    pub unsafe fn size(&self) -> size_t {
        dbm_dbmlist_t_size(self)
    }
    #[inline]
    pub unsafe fn const_head(&self) -> *const dbm_fdbm_t {
        dbm_dbmlist_t_const_head(self)
    }
    #[inline]
    pub unsafe fn head(&mut self) -> *mut dbm_fdbm_t {
        dbm_dbmlist_t_head(self)
    }
    #[inline]
    pub unsafe fn atHead(&mut self) -> *mut *mut dbm_fdbm_t {
        dbm_dbmlist_t_atHead(self)
    }
    #[inline]
    pub unsafe fn incSize(&mut self, n: size_t) {
        dbm_dbmlist_t_incSize(self, n)
    }
    #[inline]
    pub unsafe fn decSize(&mut self, n: size_t) {
        dbm_dbmlist_t_decSize(self, n)
    }
    #[inline]
    pub unsafe fn reset(&mut self, dbms: *mut dbm_fdbm_t, size: size_t) {
        dbm_dbmlist_t_reset(self, dbms, size)
    }
    #[inline]
    pub unsafe fn reset1(&mut self, l: *mut dbm_dbmlist_t) {
        dbm_dbmlist_t_reset1(self, l)
    }
    #[inline]
    pub unsafe fn intersection(&mut self, arg: *const raw_t, dim: cindex_t) -> *mut dbm_dbmlist_t {
        dbm_dbmlist_t_intersection(self, arg, dim)
    }
    #[inline]
    pub unsafe fn intersection1(
        &mut self,
        arg: *const dbm_dbm_t,
        dim: cindex_t,
    ) -> *mut dbm_dbmlist_t {
        dbm_dbmlist_t_intersection1(self, arg, dim)
    }
    #[inline]
    pub unsafe fn copyList(&self) -> dbm_dbmlist_t {
        dbm_dbmlist_t_copyList(self)
    }
    #[inline]
    pub unsafe fn steal(&mut self, dbm: *mut *mut dbm_fdbm_t, owner: *mut dbm_dbmlist_t) {
        dbm_dbmlist_t_steal(self, dbm, owner)
    }
    #[inline]
    pub unsafe fn steal1(
        &mut self,
        head: *mut *mut dbm_fdbm_t,
        dbm: *mut *mut dbm_fdbm_t,
        owner: *mut dbm_dbmlist_t,
    ) -> *mut *mut dbm_fdbm_t {
        dbm_dbmlist_t_steal1(self, head, dbm, owner)
    }
    #[inline]
    pub unsafe fn stealFromToEnd(
        &mut self,
        next: *mut *mut dbm_fdbm_t,
        dbmList: *mut dbm_dbmlist_t,
    ) {
        dbm_dbmlist_t_stealFromToEnd(self, next, dbmList)
    }
    #[inline]
    pub unsafe fn swap(&mut self, arg: *mut dbm_dbmlist_t) {
        dbm_dbmlist_t_swap(self, arg)
    }
    #[inline]
    pub unsafe fn copyRef(&mut self, arg: *mut dbm_dbmlist_t) {
        dbm_dbmlist_t_copyRef(self, arg)
    }
    #[inline]
    pub unsafe fn removeHead(&mut self) {
        dbm_dbmlist_t_removeHead(self)
    }
    #[inline]
    pub unsafe fn print(&self, os: *mut std_ostream) {
        dbm_dbmlist_t_print(self, os)
    }
    #[inline]
    pub unsafe fn err(&self) {
        dbm_dbmlist_t_err(self)
    }
    #[inline]
    pub unsafe fn out(&self) {
        dbm_dbmlist_t_out(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        dbm_dbmlist_t_dbmlist_t(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(size: size_t, flist: *mut dbm_fdbm_t) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        dbm_dbmlist_t_dbmlist_t1(__bindgen_tmp.as_mut_ptr(), size, flist);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg: *const raw_t, dim: cindex_t) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        dbm_dbmlist_t_dbmlist_t2(__bindgen_tmp.as_mut_ptr(), arg, dim);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(arg: *const dbm_dbm_t) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        dbm_dbmlist_t_dbmlist_t3(__bindgen_tmp.as_mut_ptr(), arg);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dbm_ifed_t {
    pub _base: dbm_dbmlist_t,
    pub refCounter: u32,
    pub dim: cindex_t,
}
#[test]
fn bindgen_test_layout_dbm_ifed_t() {
    assert_eq!(
        ::std::mem::size_of::<dbm_ifed_t>(),
        24usize,
        concat!("Size of: ", stringify!(dbm_ifed_t))
    );
    assert_eq!(
        ::std::mem::align_of::<dbm_ifed_t>(),
        8usize,
        concat!("Alignment of ", stringify!(dbm_ifed_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dbm_ifed_t>())).refCounter as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dbm_ifed_t),
            "::",
            stringify!(refCounter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dbm_ifed_t>())).dim as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(dbm_ifed_t),
            "::",
            stringify!(dim)
        )
    );
}
extern "C" {
    #[doc = " Creation and initialization of ifed_t. @pre the dbm is not empty."]
    #[link_name = "\u{1}create"]
    pub fn dbm_ifed_t_create(
        adbm: *const raw_t,
        dim: cindex_t,
        nxtSize: size_t,
        nxt: *mut dbm_fdbm_t,
    ) -> *mut dbm_ifed_t;
}
extern "C" {
    #[link_name = "\u{1}create"]
    pub fn dbm_ifed_t_create1(
        adbm: *const dbm_dbm_t,
        nxtSize: size_t,
        nxt: *mut dbm_fdbm_t,
    ) -> *mut dbm_ifed_t;
}
extern "C" {
    #[link_name = "\u{1}create"]
    pub fn dbm_ifed_t_create2(dim: cindex_t) -> *mut dbm_ifed_t;
}
extern "C" {
    #[link_name = "\u{1}create"]
    pub fn dbm_ifed_t_create3(dim: cindex_t, dbmlist: dbm_dbmlist_t) -> *mut dbm_ifed_t;
}
extern "C" {
    #[doc = " Update the 1st DBM, @pre size() > 0 and same dimension."]
    #[link_name = "\u{1}update"]
    pub fn dbm_ifed_t_update(this: *mut dbm_ifed_t, adbm: *const raw_t, adim: cindex_t);
}
extern "C" {
    #[link_name = "\u{1}update"]
    pub fn dbm_ifed_t_update1(this: *mut dbm_ifed_t, adbm: *const dbm_dbm_t);
}
extern "C" {
    #[doc = " Check invariants."]
    #[link_name = "\u{1}isOK"]
    pub fn dbm_ifed_t_isOK(this: *const dbm_ifed_t) -> bool;
}
extern "C" {
    #[doc = " @return dimension of this federation."]
    #[link_name = "\u{1}getDimension"]
    pub fn dbm_ifed_t_getDimension(this: *const dbm_ifed_t) -> cindex_t;
}
extern "C" {
    #[doc = " Change the dimension @pre isEmpty()"]
    #[link_name = "\u{1}setDimension"]
    pub fn dbm_ifed_t_setDimension(this: *mut dbm_ifed_t, d: cindex_t);
}
extern "C" {
    #[doc = " Set this federation to one DBM."]
    #[link_name = "\u{1}setToDBM"]
    pub fn dbm_ifed_t_setToDBM(this: *mut dbm_ifed_t, arg: *const dbm_dbm_t);
}
extern "C" {
    #[doc = " @return true if this federation is empty."]
    #[link_name = "\u{1}isEmpty"]
    pub fn dbm_ifed_t_isEmpty(this: *const dbm_ifed_t) -> bool;
}
extern "C" {
    #[doc = " Compute a hash value that does not depend on the order of the DBMs."]
    #[link_name = "\u{1}hash"]
    pub fn dbm_ifed_t_hash(this: *const dbm_ifed_t, seed: u32) -> u32;
}
extern "C" {
    #[doc = " Decrement reference count, maybe deallocate."]
    #[link_name = "\u{1}decRef"]
    pub fn dbm_ifed_t_decRef(this: *mut dbm_ifed_t);
}
extern "C" {
    #[doc = " Decrement reference count with @pre !isMutable()"]
    #[link_name = "\u{1}decRefImmutable"]
    pub fn dbm_ifed_t_decRefImmutable(this: *mut dbm_ifed_t);
}
extern "C" {
    #[doc = " Increment reference count."]
    #[link_name = "\u{1}incRef"]
    pub fn dbm_ifed_t_incRef(this: *mut dbm_ifed_t);
}
extern "C" {
    #[doc = " @return if this ifed_t can be modified."]
    #[link_name = "\u{1}isMutable"]
    pub fn dbm_ifed_t_isMutable(this: *const dbm_ifed_t) -> bool;
}
extern "C" {
    #[doc = " Remove this ifed_t with @pre isMutable()"]
    #[link_name = "\u{1}removeMutable"]
    pub fn dbm_ifed_t_removeMutable(this: *mut dbm_ifed_t);
}
extern "C" {
    #[doc = " @return copy of this ifed_t with appended list."]
    #[doc = " @pre other is mutable."]
    #[link_name = "\u{1}copy"]
    pub fn dbm_ifed_t_copy(this: *const dbm_ifed_t, other: *mut dbm_ifed_t) -> *mut dbm_ifed_t;
}
extern "C" {
    #[link_name = "\u{1}copy"]
    pub fn dbm_ifed_t_copy1(
        this: *const dbm_ifed_t,
        end: *mut dbm_fdbm_t,
        endSize: size_t,
    ) -> *mut dbm_ifed_t;
}
extern "C" {
    #[doc = " Insert a dbm, @pre same dimension & not empty."]
    #[link_name = "\u{1}insert"]
    pub fn dbm_ifed_t_insert(this: *mut dbm_ifed_t, adbm: *const dbm_dbm_t);
}
extern "C" {
    #[link_name = "\u{1}insert"]
    pub fn dbm_ifed_t_insert1(this: *mut dbm_ifed_t, adbm: *const raw_t, adim: cindex_t);
}
extern "C" {
    #[doc = " Deallocate the list + update state."]
    #[link_name = "\u{1}setEmpty"]
    pub fn dbm_ifed_t_setEmpty(this: *mut dbm_ifed_t);
}
extern "C" {
    #[doc = " Deallocate the list and set the new list to 1 DBM."]
    #[link_name = "\u{1}setDBM"]
    pub fn dbm_ifed_t_setDBM(this: *mut dbm_ifed_t, fdbm: *mut dbm_fdbm_t);
}
extern "C" {
    #[link_name = "\u{1}setFed"]
    pub fn dbm_ifed_t_setFed(this: *mut dbm_ifed_t, fdbm: *mut dbm_fdbm_t, nb: size_t);
}
impl dbm_ifed_t {
    #[inline]
    pub unsafe fn create(
        adbm: *const raw_t,
        dim: cindex_t,
        nxtSize: size_t,
        nxt: *mut dbm_fdbm_t,
    ) -> *mut dbm_ifed_t {
        dbm_ifed_t_create(adbm, dim, nxtSize, nxt)
    }
    #[inline]
    pub unsafe fn create1(
        adbm: *const dbm_dbm_t,
        nxtSize: size_t,
        nxt: *mut dbm_fdbm_t,
    ) -> *mut dbm_ifed_t {
        dbm_ifed_t_create1(adbm, nxtSize, nxt)
    }
    #[inline]
    pub unsafe fn create2(dim: cindex_t) -> *mut dbm_ifed_t {
        dbm_ifed_t_create2(dim)
    }
    #[inline]
    pub unsafe fn create3(dim: cindex_t, dbmlist: dbm_dbmlist_t) -> *mut dbm_ifed_t {
        dbm_ifed_t_create3(dim, dbmlist)
    }
    #[inline]
    pub unsafe fn update(&mut self, adbm: *const raw_t, adim: cindex_t) {
        dbm_ifed_t_update(self, adbm, adim)
    }
    #[inline]
    pub unsafe fn update1(&mut self, adbm: *const dbm_dbm_t) {
        dbm_ifed_t_update1(self, adbm)
    }
    #[inline]
    pub unsafe fn isOK(&self) -> bool {
        dbm_ifed_t_isOK(self)
    }
    #[inline]
    pub unsafe fn getDimension(&self) -> cindex_t {
        dbm_ifed_t_getDimension(self)
    }
    #[inline]
    pub unsafe fn setDimension(&mut self, d: cindex_t) {
        dbm_ifed_t_setDimension(self, d)
    }
    #[inline]
    pub unsafe fn setToDBM(&mut self, arg: *const dbm_dbm_t) {
        dbm_ifed_t_setToDBM(self, arg)
    }
    #[inline]
    pub unsafe fn isEmpty(&self) -> bool {
        dbm_ifed_t_isEmpty(self)
    }
    #[inline]
    pub unsafe fn hash(&self, seed: u32) -> u32 {
        dbm_ifed_t_hash(self, seed)
    }
    #[inline]
    pub unsafe fn decRef(&mut self) {
        dbm_ifed_t_decRef(self)
    }
    #[inline]
    pub unsafe fn decRefImmutable(&mut self) {
        dbm_ifed_t_decRefImmutable(self)
    }
    #[inline]
    pub unsafe fn incRef(&mut self) {
        dbm_ifed_t_incRef(self)
    }
    #[inline]
    pub unsafe fn isMutable(&self) -> bool {
        dbm_ifed_t_isMutable(self)
    }
    #[inline]
    pub unsafe fn removeMutable(&mut self) {
        dbm_ifed_t_removeMutable(self)
    }
    #[inline]
    pub unsafe fn copy(&self, other: *mut dbm_ifed_t) -> *mut dbm_ifed_t {
        dbm_ifed_t_copy(self, other)
    }
    #[inline]
    pub unsafe fn copy1(&self, end: *mut dbm_fdbm_t, endSize: size_t) -> *mut dbm_ifed_t {
        dbm_ifed_t_copy1(self, end, endSize)
    }
    #[inline]
    pub unsafe fn insert(&mut self, adbm: *const dbm_dbm_t) {
        dbm_ifed_t_insert(self, adbm)
    }
    #[inline]
    pub unsafe fn insert1(&mut self, adbm: *const raw_t, adim: cindex_t) {
        dbm_ifed_t_insert1(self, adbm, adim)
    }
    #[inline]
    pub unsafe fn setEmpty(&mut self) {
        dbm_ifed_t_setEmpty(self)
    }
    #[inline]
    pub unsafe fn setDBM(&mut self, fdbm: *mut dbm_fdbm_t) {
        dbm_ifed_t_setDBM(self, fdbm)
    }
    #[inline]
    pub unsafe fn setFed(&mut self, fdbm: *mut dbm_fdbm_t, nb: size_t) {
        dbm_ifed_t_setFed(self, fdbm, nb)
    }
}
extern "C" {
    #[doc = " Encoding of bound into (strict) less or less equal."]
    #[doc = " @param bound,strict: the bound to encode with the strictness."]
    #[doc = " @return encoded constraint (\"raw\")."]
    pub fn dbm_bound2raw_exposed(raw: raw_t, strict: strictness_t) -> i32;
}
extern "C" {
    #[doc = " Encoding of bound into (strict) less or less equal."]
    #[doc = " @param bound,isStrict: the bound to encode with a flag"]
    #[doc = " telling if the bound is strict or not."]
    #[doc = " if isStrict is TRUE then dbm_STRICT is taken,"]
    #[doc = " otherwise dbm_WEAK."]
    #[doc = " @return encoded constraint (\"raw\")."]
    pub fn dbm_boundbool2raw_exposed(raw: raw_t, isStrict: bool) -> i32;
}
extern "C" {
    #[doc = " Decoding of raw representation: bound."]
    #[doc = " @param raw: encoded constraint (bound + strictness)."]
    #[doc = " @return the decoded bound value."]
    pub fn dbm_raw2bound_exposed(raw: raw_t) -> i32;
}
extern "C" {
    #[doc = " Set the DBM so that it contains only 0."]
    #[doc = " @param dbm: DBM to set to 0"]
    #[doc = " @param dim: dimension"]
    #[doc = " @return zeroed DBM"]
    #[doc = " @post DBM is closed"]
    pub fn dbm_zero_exposed(dbm: *mut raw_t, dim: cindex_t);
}
extern "C" {
    #[doc = " Tests of strictness."]
    #[doc = " @param raw: encoded constraint (bound + strictness)."]
    #[doc = " @return TRUE if the constraint is strict."]
    #[doc = " dbm_rawIsStrict(x) == !dbm_rawIsEq(x)"]
    pub fn dbm_rawIsStrict_exposed(raw: raw_t) -> BOOL;
}
extern "C" {
    #[doc = " Constraint addition on raw values : + constraints - excess bit."]
    #[doc = " @param x,y: encoded constraints to add."]
    #[doc = " @return encoded constraint x+y."]
    pub fn dbm_addRawRaw_exposed(x: raw_t, y: raw_t) -> raw_t;
}
extern "C" {
    #[doc = " Subtract DBM arg1 - DBM arg2 wrapper functions."]
    pub fn dbm_subtract1_exposed(
        arg1: *const raw_t,
        arg2: *const raw_t,
        dim: cindex_t,
    ) -> dbm_fed_t;
}
extern "C" {
    pub fn dbm_subtract2_exposed(arg1: *const dbm_dbm_t, arg2: *const raw_t) -> dbm_fed_t;
}
extern "C" {
    pub fn dbm_subtract3_exposed(arg1: *const dbm_dbm_t, arg2: *const dbm_dbm_t) -> dbm_fed_t;
}
extern "C" {
    #[doc = " Satisfy operation."]
    #[doc = " Check if a DBM satisfies a constraint. The DBM is not modified."]
    #[doc = " WARNING: using this for conjunction of constraints is incorrect"]
    #[doc = " because the DBM is not modified."]
    #[doc = " @param dbm: DBM."]
    #[doc = " @param dim: dimension."]
    #[doc = " @param i,j: indices of clocks for the clock constraint."]
    #[doc = " @param constraint: the encoded constraint."]
    #[doc = " @pre"]
    #[doc = " - DBM is closed and non empty."]
    #[doc = " - dim > 0"]
    #[doc = " - i != j (don't touch the diagonal)"]
    #[doc = " - i < dim, j < dim"]
    #[doc = " @return TRUE if the DBM satisfies the constraint."]
    pub fn dbm_satisfies_exposed(
        dbm: *const raw_t,
        dim: cindex_t,
        i: cindex_t,
        j: cindex_t,
        constraint: raw_t,
    ) -> BOOL;
}
#[test]
fn __bindgen_test_layout_dbm_Valuation_open0_int32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<dbm_Valuation<i32>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(dbm_Valuation<i32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<dbm_Valuation<i32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(dbm_Valuation<i32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_dbm_Valuation_open0_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<dbm_Valuation<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(dbm_Valuation<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<dbm_Valuation<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(dbm_Valuation<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_base_pointer_t_open0_constraint_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<base_pointer_t<constraint_t>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(base_pointer_t<constraint_t>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<base_pointer_t<constraint_t>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(base_pointer_t<constraint_t>)
        )
    );
}
#[test]
fn __bindgen_test_layout_dbm_ClockOperation_open0_dbm_dbm_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<dbm_ClockOperation<dbm_dbm_t>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(dbm_ClockOperation<dbm_dbm_t>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<dbm_ClockOperation<dbm_dbm_t>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(dbm_ClockOperation<dbm_dbm_t>)
        )
    );
}
#[test]
fn __bindgen_test_layout_base_pointer_t_open0_constraint_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<base_pointer_t<constraint_t>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(base_pointer_t<constraint_t>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<base_pointer_t<constraint_t>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(base_pointer_t<constraint_t>)
        )
    );
}
#[test]
fn __bindgen_test_layout_dbm_ClockOperation_open0_dbm_fed_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<dbm_ClockOperation<dbm_fed_t>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(dbm_ClockOperation<dbm_fed_t>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<dbm_ClockOperation<dbm_fed_t>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(dbm_ClockOperation<dbm_fed_t>)
        )
    );
}
#[doc = " Simple adapter to tie together the hash table and"]
#[doc = " bucket types."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bucket_t {
    pub _base: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_Bucket_t() {
    assert_eq!(
        ::std::mem::size_of::<Bucket_t>(),
        24usize,
        concat!("Size of: ", stringify!(Bucket_t))
    );
    assert_eq!(
        ::std::mem::align_of::<Bucket_t>(),
        8usize,
        concat!("Alignment of ", stringify!(Bucket_t))
    );
}
